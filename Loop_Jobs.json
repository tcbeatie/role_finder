{
  "name": "Loop Jobs v4.1",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "id": "5d74d3c6-b9b3-491d-91cf-0fdc8417a332",
      "name": "Start",
      "notes": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  NODE 1: WORKFLOW TRIGGER (SUB-WORKFLOW ENTRY\n  POINT)  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  This is the entry point for the Job workflow,\n  which is called as a SUB-WORKFLOW from the\n  parent \"Loop Companies v2.1\" workflow.\n\n  How this workflow gets triggered:\n . Sub-workflow call: Parent workflow calls\n     this via Execute Workflow node\n     - Parent passes job data with _context_\n       fields\n     - This workflow processes jobs\n       independently\n     - Returns control to parent when complete\n\n  What data arrives here (FROM PARENT WORKFLOW\n  v3.1):\n  When called from parent workflow, receives job\n  items with:\n\n  === APIFY JOB FIELDS ===\n  - id: Apify's unique job identifier\n  - title: Job title (\"Senior Technical Product\n    Manager\")\n  - organization: Company name (\"Anthropic\")\n  - salary fields: ai_salary_minvalue,\n    ai_salary_maxvalue, ai_salary_currency\n  - location fields: locations_raw,\n    remote_derived, ai_work_arrangement\n  - description_text: Full job description\n  - url: Link to apply\n  - date_posted: When job was posted\n  - experience_level: Apify's AI-extracted\n    experience level\n  ... and many more Apify fields\n\n  === COMPANY CONTEXT FIELDS ===\n  - _context_workflow_run_id: Parent workflow's\n    execution ID\n  - _context_company_id: Company identifier\n    (\"anthropic\")\n  - _context_company_name: Company display name\n    (\"Anthropic\")\n  - _context_domain: Company domain\n    (\"anthropic.com\")\n\n  === PROFILE CONTEXT FIELDS ===\n  These are added by parent workflow's \"Add\n  Context\" node:\n  - _context_profile_id: Candidate profile\n    identifier (\"[id]\")\n  - _context_resume_text: Complete resume/\n    experience text for AI evaluation\n  - _context_target_criteria: Job search\n    criteria JSON\n\n  1. NO HARDCODED DATA: Workflow is profile-\n     agnostic\n  2. MULTI-USER READY: Different users can have\n     different profiles\n  3. TESTING FRIENDLY: Can test with different\n     profiles without editing workflow\n  4. SEPARATION OF CONCERNS: Parent handles\n     profile, this workflow handles evaluation\n  5. REUSABILITY: Same workflow can evaluate\n     jobs for any candidate\n  6. SIMPLER FLOW: One less node to maintain\n  7. VERSION CONTROL: Workflow JSON contains no\n     personal information\n  8. SECURITY: Profile can be stored encrypted\n     in database\n\n  Data flow visualization:\n  Start (receives jobs with _context_resume_text)\n  â†’ Loop Over Jobs (one job at a time) â†’\n    PARALLEL SPLIT:\n      Path A: Message a model (AI uses\n              _context_resume_text) â†’ Parse â†’\n              Merge\n      Path B: Direct to Merge (preserves raw\n              data) â†’\n    MERGE â†’ Format Job Card â†’ Save to Email\n    Queue â†’ Loop back\n\n  Workflow purpose:\n  Process jobs ONE AT A TIME through:\n  1. Loop Over Jobs: Iterate through jobs (fault\n     tolerance)\n  2. Message a model: AI evaluation with Claude\n     Sonnet 4.5 using _context_resume_text\n  3. Parse AI Response: Extract and structure\n     evaluation\n  4. Merge: Combine AI evaluation with raw job\n     data (parallel paths)\n  5. Format Job Card: Generate HTML email card\n  6. Save to Email Queue: Store for email\n     aggregation\n\n  Next node: Loop Over Jobs\n"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        208,
        0
      ],
      "id": "254454e3-0700-431f-9e49-256a4cb8cbea",
      "name": "Loop Over Jobs",
      "notes": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  NODE 2: LOOP OVER JOBS (JOB PROCESSING\n  ORCHESTRATOR)  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  Processes jobs ONE AT A TIME using a loop\n  pattern.\n\n  What is this loop doing?\n  - Takes array of jobs passed from parent\n    workflow (e.g., 8 jobs from Anthropic)\n  - Each job already includes _context_ fields\n    with profile data\n  - Processes each job individually through AI\n    evaluation\n  - Batch size: 1 (default) means one job per\n    loop iteration\n\n  Why loop over jobs individually?\n  1. AI API RATE LIMITING: Avoid overwhelming\n     Claude API with parallel requests\n  2. COST TRACKING: Know exact number of AI\n     calls and costs\n  3. PROGRESS MONITORING: See real-time progress\n     through jobs\n  4. ERROR ISOLATION: If job #5 fails, jobs\n     #6-8 still process\n  5. SEQUENTIAL EVALUATION: Each job gets full\n     AI attention\n  6. BUDGET CONTROL: Can stop mid-run if needed\n\n  How the loop works:\n  â”Œâ”€ Loop iteration 1: Job 1 (\"Senior PM at\n  â”‚  Anthropic\")\n  â”‚  â”œâ”€ Split to AI path + raw data path\n  â”‚     (parallel)\n  â”‚  â”œâ”€ AI Evaluation â†’ Parse â†’ Merge\n  â”‚  â”œâ”€ Raw data â†’ Merge\n  â”‚  â”œâ”€ Format â†’ Save to email queue\n  â”‚  â””â”€ Return to loop node\n  â”‚\n  â”œâ”€ Loop iteration 2: Job 2 (\"Lead PM at\n  â”‚  Anthropic\")\n  â”‚  â”œâ”€ Same parallel processing\n  â”‚  â””â”€ Return to loop node\n  â”‚\n  â””â”€ All jobs done â†’ Done branch activates\n\n  Two outputs (pins on the node):\n  1. DONE BRANCH (top pin):\n     - Fires ONCE after ALL jobs for current\n       company complete\n     - Routes to: Workflow Complete\n     - Signals to parent workflow: \"All jobs\n       processed, ready for next company\"\n\n  2. LOOP BRANCH (bottom pin):\n     - Fires ONCE PER JOB\n     - Routes to TWO nodes in parallel:\n       â€¢ Message a model (AI evaluation path)\n       â€¢ Merge (raw data preservation path)\n     - This parallel split is key to the\n       architecture\n\n  Accessing current job in downstream nodes:\n  $('Loop Over Jobs').item.json\n  // This gives you the current job being\n  // processed\n  // Includes ALL fields from parent workflow:\n  // {\n  //   id: \"12345\",\n  //   title: \"Senior PM\",\n  //   description_text: \"...\",\n  //   _context_workflow_run_id: 67890,\n  //   _context_company_id: \"anthropic\",\n  //   _context_company_name: \"Anthropic\",\n  //   _context_resume_text: \"[resume]\",\n  //   _context_target_criteria: \"{...}\",\n  //   _context_profile_id: \"[id]\",\n  //   ... all other Apify fields\n  // }\n\n  Profile context availability (v3.1):\n  EVERY job in the loop has access to:\n  - _context_resume_text: Full resume for AI\n    evaluation (used in Message a model)\n  - _context_target_criteria: Search criteria\n    (for reference/future use)\n  - _context_profile_id: Profile identifier\n    (for tracking)\n\n  Parallel processing pattern:\n  After Loop Over Jobs, the job data flows to\n  TWO destinations simultaneously:\n\n  Path A (AI Evaluation - Slow):\n  â””â”€ Message a model (2-5 seconds, costs $0.003)\n     â””â”€ Parse AI Response\n        â””â”€ Merge (input 0)\n\n  Path B (Raw Data - Fast):\n  â””â”€ Merge (input 1, instant, free)\n\n  Why both paths?\n  - Path A: Gets AI intelligence and scoring\n  - Path B: Preserves complete job data\n  - Merge: Combines AI evaluation with raw job\n    fields\n  - Result: Job with BOTH AI scores AND all\n    original details\n\n  Timing example:\n  If Anthropic has 8 jobs:\n  - Loop executes 8 times (once per job)\n  - Each iteration: 2-5 seconds for AI\n    evaluation\n  - Total: 16-40 seconds for all 8 jobs\n  - Then Done branch fires once\n  - Parent workflow continues to next company\n\n  Loop-back path:\n  Save to Email Queue â†’ Loop Over Jobs â†’\n  (next job iteration)\n\n  When all jobs complete:\n  Loop Over Jobs (Done) â†’ Workflow Complete â†’\n  Return to parent\n\n  Next nodes (PARALLEL):\n  - Loop branch (AI path) â†’ Message a model\n  - Loop branch (Raw path) â†’ Merge (input 1)\n"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================================\n// NODE: WORKFLOW COMPLETE\n// Signals successful completion back to parent workflow\n// ============================================================================\n\n  // Get count from earlier in the workflow, not from input\n  const processedJobs = $('Insert email row').all();\n\n  return [{\n    json: {\n      status: 'success',\n      jobs_processed: processedJobs.length,\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n// Output: Simple success signal with job count\n// Parent workflow receives this and continues to next company"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        416,
        -96
      ],
      "id": "e3090b1c-c1f6-4946-9dde-06d23c47ba2d",
      "name": "Workflow Complete",
      "notes": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  NODE 8: WORKFLOW COMPLETE\n  Signals successful completion back to parent\n  workflow  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  Get all items that came through the loop (for\n  counting)\n  const allItems = $input.all();\n\n  return [{\n    json: {\n      status: 'success',\n      jobs_processed: allItems.length,\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n  Output: Simple success signal with job count\n  Parent workflow receives this and continues to\n  next company\n"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "claude-sonnet-4-5-20250929"
        },
        "messages": {
          "values": [
            {
              "content": "=Candidate Profile:\n{{ $json._context_resume_text }}\n\nJob Details:\n- Job ID: {{ $json.id }}\n- Title: {{ $json.title }}\n- Company: {{ $json.organization }}\n- Location: {{ $json.locations_derived || $json.location_locality }}, {{ $json.regions_derived || $json.location_region }} (Remote: {{ $json.remote_derived }})\n- Work Arrangement: {{ $json.ai_work_arrangement }}\n- Salary: {{ $json.ai_salary_minvalue }} - {{ $json.ai_salary_maxvalue }} {{ $json.ai_salary_currency }}\n- Experience Level: {{ $json.ai_experience_level }}\n- URL: {{ $json.url }}\n\nJob Description:\n{{ $json.description_text }}\n\nEvaluate this job against the candidate's profile and return ONLY valid JSON with this exact structure:\n\n{\n  \"job_id\": \"{{ $json.id }}\",\n  \"overall_score\": <number 1-10>,\n  \"recommendation\": \"<EXCELLENT_MATCH|GOOD_MATCH|CONSIDER|POOR_FIT|REJECT>\",\n  \"detailed_scores\": {\n    \"seniority_match\": <number 1-10>,\n    \"domain_match\": <number 1-10>,\n    \"technical_depth\": <number 1-10>,\n    \"location_fit\": <number 1-10>,\n    \"compensation\": <number 1-10>\n  },\n  \"reasoning\": {\n    \"strengths\": [<array of 3-6 specific strengths>],\n    \"weaknesses\": [<array of key concerns or gaps>],\n    \"key_mismatches\": [<array of critical misalignments if any>]\n  },\n  \"match_explanation\": \"<2-4 sentence summary explaining the overall assessment>\"\n}\n\nCRITICAL: You must include \"job_id\": \"{{ $json.id }}\" as the first field in your JSON response.\n\nScoring criteria:\n- Seniority: Senior/Lead/Principal/Director level roles (not Associate/Junior)\n- Domain: Infrastructure, Platform Engineering, Developer Experience, API platforms, Cloud systems\n- Technical Depth: Backend systems, integrations, developer tools expertise required\n- Location: Remote, Hybrid NYC Metro, or Hybrid Bay Area (10=perfect, 0=dealbreaker)\n- Compensation: $190k+ is threshold (10 if well above, 0 if below)\n\nReturn only the JSON, no markdown formatting."
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.anthropic",
      "typeVersion": 1,
      "position": [
        576,
        16
      ],
      "id": "6cdfae3d-ee7c-4507-b04d-7fd784e86e64",
      "name": "Message a model",
      "credentials": {
        "anthropicApi": {
          "id": "6qsUxIs7jlIJ6qQ8",
          "name": "Anthropic account"
        }
      },
      "notes": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  NODE 3: AI JOB EVALUATION (CLAUDE SONNET 4.5)  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  Sends job + candidate profile to Claude AI for\n  intelligent evaluation.\n\n  What this node does:\n  Calls Anthropic's Claude API with:\n  1. Complete candidate profile via\n     _context_resume_text (from parent workflow)\n  2. Full job details (title, company, salary,\n     location, description)\n  3. Structured evaluation prompt with scoring\n     dimensions\n\n  AI Model: claude-sonnet-4-5-20250929\n  - Anthropic's Claude Sonnet 4.5 model\n  - Fast, high-quality reasoning\n  - Excellent at structured output (JSON)\n  - Strong at comparative analysis\n  - Optimized for tool use and long-context\n    understanding\n\n  Prompt structure breakdown:\n\n  === SECTION 1: CANDIDATE PROFILE ===\n  {{ $json._context_resume_text }}\n\n  The _context_resume_text field contains the\n  complete candidate profile:\n  - Professional summary\n  - Key achievements\n  - Technical expertise\n  - Recent experience (detailed)\n  - Target role criteria\n  - Ideal fit indicators\n\n  === SECTION 2: JOB DETAILS ===\n  All relevant job fields extracted from Apify\n  data:\n  - {{ $json.id }}: Unique job identifier\n    (critical for merge)\n  - {{ $json.title }}: Job title\n  - {{ $json.organization }}: Company name\n  - {{ $json.locations_derived }}: Location\n    information\n  - {{ $json.ai_salary_minvalue }}: Salary range\n  - {{ $json.description_text }}: Full job\n    description\n\n  === SECTION 3: EVALUATION STRUCTURE ===\n  Prompt instructs AI to return JSON with:\n\n  1. OVERALL ASSESSMENT:\n     - overall_score: 1-10 rating\n     - recommendation: EXCELLENT_MATCH |\n       GOOD_MATCH | CONSIDER | POOR_FIT | REJECT\n     - match_explanation: 2-4 sentence summary\n\n  2. DETAILED SCORES (5 dimensions, each 1-10):\n     - seniority_match: Is this Senior/Lead/\n       Principal/Director level?\n     - domain_match: Infrastructure/Platform/\n       DevEx/API/Cloud focus?\n     - technical_depth: Backend systems/\n       integrations/developer tools?\n     - location_fit: Remote, Hybrid NYC Metro, or\n       Hybrid Bay Area?\n     - compensation: Meets $190k+ threshold?\n\n  3. REASONING:\n     - strengths: 3-6 specific reasons this job\n       is a good fit\n     - weaknesses: Key concerns or gaps\n     - key_mismatches: Critical dealbreakers\n       (if any)\n\n  Why include job_id in AI response?\n  CRITICAL: The job_id field is explicitly\n  requested in the prompt template. This ensures\n  the AI's response can be matched back to the\n  original job in the Merge node. The Merge node\n  uses:\n  - AI response: job_id field\n  - Raw job data: id field\n  These must match for proper merging.\n\n  Timing:\n  - API latency: 2-5 seconds per job (depends on\n    job description length)\n  - Parallel processing: NO (sequential loop\n    prevents API throttling)\n  - For 8 Anthropic jobs: 16-40 seconds total\n\n  Error handling:\n  - If AI fails: Error passed to downstream\n    nodes\n  - n8n catches errors in execution log\n  - Could implement retry logic for transient\n    failures\n  - Parse node validates JSON structure\n    downstream\n\n  Why this is the \"slow path\":\n  Compared to the parallel \"raw data\" path that\n  goes directly to Merge:\n  - AI path (this node): 2-5 seconds per job,\n    costs $0.003\n  - Raw path (parallel): Instant, free\n\n  Both paths are necessary:\n  - AI path provides intelligence and evaluation\n    (this node â†’ Parse â†’ Merge input 0)\n  - Raw path preserves complete job data (direct\n    to Merge input 1)\n  - Merge combines both for complete\n    job+evaluation object\n\n  Production considerations:\n  1. RATE LIMITING: Sequential processing avoids\n     API throttling\n  2. COST MONITORING: Track usage via Anthropic\n     dashboard\n  3. QUALITY CHECKS: Validate AI responses are\n     well-structured\n  4. A/B TESTING: Could test different prompts\n     or scoring criteria\n  5. CACHING: Could cache evaluations for\n     identical jobs (future enhancement)\n  6. PROMPT TUNING: Adjust scoring criteria\n     based on false positives/negatives\n\n  Next node: Parse AI Response"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================================\n// NODE 5: PARSE AI RESPONSE\n// Extracts and structures AI evaluation from Claude's JSON response\n// ============================================================================\n\n// THE PROBLEM:\n// Claude returns its evaluation in a specific format:\n// $json.content[0].text contains the actual JSON string\n// We need to:\n// 1. Extract the JSON string\n// 2. Clean up any markdown formatting\n// 3. Parse into JavaScript object\n// 4. Restructure for database and merge compatibility\n\n// STEP 1: Extract raw response text from Claude's response structure\nlet response = $json.content[0].text;\n// Example: \"```json\\n{...}\\n```\" or \"{...}\"\n\n// STEP 2: Clean up markdown code fences if present\n// Claude sometimes wraps JSON in markdown code blocks\n// Remove: ```json at start and ``` at end\nresponse = response.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n// Now we have clean JSON string: \"{...}\"\n\n// STEP 3: Parse JSON string into JavaScript object\nconst evaluation = JSON.parse(response);\n// If parsing fails, this will throw an error (caught by n8n error handling)\n\n// STEP 4: Restructure into standardized format\nreturn [{\n  json: {\n    // === CRITICAL: Extract job_id for merge matching ===\n    // This MUST match the job ID from the raw job data\n    // The Merge node uses this to link AI evaluation to correct job\n    job_id: evaluation.job_id,\n    \n    // === Full evaluation object for reference ===\n    // Store complete AI response in case we need it later\n    // ai_evaluation: evaluation,\n    \n    // === Top-level fields for easy access ===\n    // Extract commonly-used fields to top level\n    overall_score: evaluation.overall_score,\n    recommendation: evaluation.recommendation,\n    \n    // === Reasoning details ===\n    // Extract arrays from nested reasoning object\n    // Use || [] to provide empty array fallback if field missing\n    strengths: evaluation.reasoning?.strengths || [],\n    weaknesses: evaluation.reasoning?.weaknesses || [],\n    key_mismatches: evaluation.reasoning?.key_mismatches || [],\n    match_explanation: evaluation.match_explanation || '',\n    \n    // === Individual scoring dimensions ===\n    // Extract each score from nested detailed_scores object\n    // Use || 0 to provide default score if field missing\n    seniority_match: evaluation.detailed_scores?.seniority_match || 0,\n    domain_match: evaluation.detailed_scores?.domain_match || 0,\n    technical_depth: evaluation.detailed_scores?.technical_depth || 0,\n    location_fit: evaluation.detailed_scores?.location_fit || 0,\n    compensation_fit: evaluation.detailed_scores?.compensation || 0\n  }\n}];\n\n// WHAT GETS OUTPUT:\n// Flattened, structured evaluation data\n// Example:\n// {\n//   job_id: \"12345\",\n//   ai_evaluation: { <full nested object> },\n//   overall_score: 9,\n//   recommendation: \"EXCELLENT_MATCH\",\n//   strengths: [\"Senior level\", \"Infrastructure focus\", ...],\n//   weaknesses: [\"May require ML expertise\"],\n//   key_mismatches: [],\n//   match_explanation: \"This is an excellent match...\",\n//   seniority_match: 10,\n//   domain_match: 9,\n//   technical_depth: 8,\n//   location_fit: 10,\n//   compensation_fit: 9\n// }\n\n// WHY FLATTEN THE STRUCTURE?\n// 1. EASIER MERGE: Top-level fields merge cleanly with job data\n// 2. DATABASE FRIENDLY: Can map directly to table columns\n// 3. EMAIL FORMATTING: Easy access to scores and arrays\n// 4. BACKUP: Keep full ai_evaluation object for reference\n\n// WHY job_id IS CRITICAL:\n// The Merge node (next step) needs to match this AI evaluation\n// with the corresponding raw job data. It does this by comparing:\n// - AI evaluation: job_id field (from this node)\n// - Raw job data: id field (from parallel path)\n// \n// If job_id is missing or incorrect:\n// - Merge will fail to match\n// - AI evaluation gets orphaned\n// - Job card generation breaks\n\n// ERROR HANDLING:\n// If JSON.parse() fails:\n// - n8n catches error and shows in execution log\n// - Can add try/catch for graceful error handling\n// - Could implement retry logic\n// - Could log malformed responses for debugging\n\n// VALIDATION CHECKS (could be added):\n// - Verify job_id exists and matches expected format\n// - Confirm overall_score is 1-10\n// - Validate recommendation is one of allowed values\n// - Check that required fields are present\n// - Ensure arrays are actually arrays\n\n// ARCHITECTURAL NOTE:\n// This node completes the \"AI evaluation path\" (Path A).\n// The parsed evaluation now flows to Merge node where it combines\n// with raw job data from the parallel \"raw data path\" (Path B).\n\n// Parallel path recap:\n// Path A (AI evaluation - slow): \n//   Add Resume Context â†’ Message a model â†’ Parse AI Response â†’ Merge (input 1)\n// \n// Path B (Raw data - fast):\n//   Add Resume Context â†’ Merge (input 2)\n// \n// Merge node receives BOTH:\n// - Input 1: AI evaluation (this node's output)\n// - Input 2: Complete job data (direct from Add Resume Context)\n// \n// Result: Job with BOTH AI evaluation AND all original job fields\n\n// Next node: Merge (input 1)\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        16
      ],
      "id": "a780ab1d-961c-4ced-8382-98ea898abf9f",
      "name": "Parse AI Response",
      "notes": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  NODE 4: PARSE AI RESPONSE\n  Extracts and structures AI evaluation from\n  Claude's JSON response  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  THE PROBLEM:\n  Claude returns its evaluation in a specific\n  format:\n  $json.content[0].text contains the actual JSON\n  string\n  We need to:\n  1. Extract the JSON string\n  2. Clean up any markdown formatting\n  3. Parse into JavaScript object\n  4. Restructure for database and merge\n     compatibility\n\n  STEP 1: Extract raw response text from\n  Claude's response structure\n  let response = $json.content[0].text;\n  // Example: \"```json\\n{...}\\n```\" or \"{...}\"\n\n  STEP 2: Clean up markdown code fences if\n  present\n  // Claude sometimes wraps JSON in markdown\n  // code blocks\n  // Remove: ```json at start and ``` at end\n  response = response.replace(/```json\\n?/g,\n    '').replace(/```\\n?/g, '').trim();\n  // Now we have clean JSON string: \"{...}\"\n\n  STEP 3: Parse JSON string into JavaScript\n  object\n  const evaluation = JSON.parse(response);\n  // If parsing fails, this will throw an error\n  // (caught by n8n error handling)\n\n  STEP 4: Restructure into standardized format\n  return [{\n    json: {\n      // === CRITICAL: Extract job_id for merge\n      // matching ===\n      // This MUST match the job ID from the raw\n      // job data\n      // The Merge node uses this to link AI\n      // evaluation to correct job\n      job_id: evaluation.job_id,\n\n      // === Full evaluation object for\n      // reference ===\n      // Store complete AI response in case we\n      // need it later\n      // Useful for debugging or future analysis\n      ai_evaluation: evaluation,\n\n      // === Top-level fields for easy access ===\n      // Extract commonly-used fields to top\n      // level\n      // Makes downstream formatting easier\n      overall_score: evaluation.overall_score,\n      recommendation: evaluation.recommendation,\n\n      // === Reasoning details ===\n      // Extract arrays from nested reasoning\n      // object\n      // Use || [] to provide empty array\n      // fallback if field missing\n      // This prevents errors in downstream\n      // formatting\n      strengths: evaluation.reasoning?.strengths\n        || [],\n      weaknesses: evaluation.reasoning?.weaknesses\n        || [],\n      key_mismatches:\n        evaluation.reasoning?.key_mismatches || [],\n      match_explanation:\n        evaluation.match_explanation || '',\n\n      // === Individual scoring dimensions ===\n      // Extract each score from nested\n      // detailed_scores object\n      // Use || 0 to provide default score if\n      // field missing\n      seniority_match:\n        evaluation.detailed_scores?.seniority_match\n        || 0,\n      domain_match:\n        evaluation.detailed_scores?.domain_match\n        || 0,\n      technical_depth:\n        evaluation.detailed_scores?.technical_depth\n        || 0,\n      location_fit:\n        evaluation.detailed_scores?.location_fit\n        || 0,\n      compensation_fit:\n        evaluation.detailed_scores?.compensation\n        || 0\n    }\n  }];\n\n  WHAT GETS OUTPUT:\n  Flattened, structured evaluation data\n\n  WHY FLATTEN THE STRUCTURE?\n  1. EASIER MERGE: Top-level fields merge\n     cleanly with job data\n  2. DATABASE FRIENDLY: Can map directly to\n     table columns\n  3. EMAIL FORMATTING: Easy access to scores and\n     arrays\n  4. BACKUP: Keep full ai_evaluation object for\n     reference\n  5. QUERY FRIENDLY: Can query by score without\n     parsing JSON\n\n  WHY job_id IS CRITICAL:\n  The Merge node (next step) needs to match this\n  AI evaluation with the corresponding raw job\n  data. It does this by comparing:\n  - AI evaluation (this output): job_id field\n  - Raw job data (parallel path): id field\n\n  Match logic: WHERE job_id == id\n\n  If job_id is missing or incorrect:\n  - Merge will fail to find matching pair\n  - AI evaluation gets orphaned\n  - Job card generation breaks\n  - Email doesn't include this job\n\n  ERROR HANDLING:\n  If JSON.parse() fails:\n  - n8n catches error and shows in execution log\n  - Can add try/catch for graceful error\n    handling\n  - Could implement retry logic with different\n    prompt\n  - Could log malformed responses for debugging\n  - Could alert on repeated failures\n\n  VALIDATION CHECKS (could be added for\n  production):\n  - Verify job_id exists and matches expected\n    format\n  - Confirm overall_score is 1-10\n  - Validate recommendation is one of allowed\n    values\n  - Check that required fields are present\n  - Ensure arrays are actually arrays\n  - Validate score ranges (1-10)\n\n  Merge node receives BOTH:\n  - Input 0: AI evaluation (this node's output)\n  - Input 1: Complete job data with _context_\n    fields (from Loop Over Jobs)\n\n  Result: Job with BOTH AI evaluation AND all\n  original job fields\n\n  PRODUCTION MONITORING:\n  Track these metrics:\n  - Parse success rate\n  - Average overall_score (helps calibrate\n    scoring)\n  - Most common recommendations\n  - Frequency of key_mismatches\n  - AI response time trends\n  - Cost per evaluation\n\n  Next node: Merge (input 0)"
    },
    {
      "parameters": {
        "mode": "combine",
        "advanced": true,
        "mergeByFields": {
          "values": [
            {
              "field1": "job_id",
              "field2": "id"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1136,
        288
      ],
      "id": "24b22e6a-58b1-4030-badd-53801021f078",
      "name": "Merge",
      "notes": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  NODE 5: MERGE AI EVALUATION WITH RAW JOB DATA  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  Combines AI evaluation results with complete\n  job data from Apify.\n\n  What is this node doing?\n  The Merge node receives data from TWO parallel\n  paths and combines them:\n\n  INPUT 0 (Top pin - AI evaluation path):\n  Comes from: Parse AI Response\n  Contains:\n  - job_id: \"12345\" (for matching)\n  - overall_score: 9\n  - recommendation: \"EXCELLENT_MATCH\"\n  - detailed scores: seniority_match,\n    domain_match, etc.\n  - reasoning arrays: strengths, weaknesses,\n    key_mismatches\n  - match_explanation: AI's summary text\n  - ai_evaluation: Full nested evaluation object\n\n  INPUT 1 (Bottom pin - Raw job data path):\n  Comes from: Loop Over Jobs (DIRECT connection\n  in v3.1)\n  Contains:\n  - id: \"12345\" (matches job_id from Input 0)\n  - All Apify fields: title, organization,\n    salary, location, description_text\n  - All _context_ fields: workflow_run_id,\n    company_id, company_name, domain\n  - Profile context fields: _context_resume_text,\n    _context_profile_id, _context_target_criteria\n\n  Merge Mode: Combine by Fields\n  - Matches items based on specified field pairs\n  - Field 1 (from Input 0): job_id\n  - Field 2 (from Input 1): id\n  - When job_id == id, combine those items into\n    single object\n\n  Why we need both inputs:\n  1. AI EVALUATION (Input 0):\n     - Provides intelligence and scoring\n     - Claude only returns what we asked for\n       (evaluation JSON)\n\n  2. RAW JOB DATA (Input 1):\n     - Preserves ALL original Apify fields\n     - Includes _context_ fields for tracking and\n       grouping\n     - Includes _context_resume_text (though not\n       used after AI evaluation)\n\n  3. MERGED OUTPUT:\n     - Best of both worlds\n     - AI scores + Complete job details +\n       Context fields\n     - Everything needed for email formatting\n     - Single comprehensive object per job\n\n  Critical: Why job_id must match id\n  If job_id (Input 0) != id (Input 1):\n  - Merge fails to find matching pair\n  - Items don't combine\n  - Downstream nodes receive incomplete data\n  - Email formatting breaks\n  - Job doesn't appear in email\n\n  This is why we explicitly include job_id in\n  the AI prompt template. The AI is instructed:\n  \"You must include \\\"job_id\\\": \\\"{{ $json.id\n  }}\\\"...\"\n\n  Parallel path timing:\n  The two inputs arrive at DIFFERENT speeds:\n  - Input 0 (AI path): 2-5 seconds (slow - API\n    call + processing)\n  - Input 1 (Raw path): Instant (fast - no\n    processing)\n\n  The Merge node WAITS for both inputs before\n  proceeding. This is automatic n8n behavior -\n  merge nodes don't fire until they have data on\n  all input pins.\n\n  Behavior during the wait:\n  - Fast path (Input 1) arrives first and queues\n  - Merge node holds and waits\n  - Slow path (Input 0) arrives 2-5 seconds\n    later\n  - Merge node matches by job_id == id\n  - Combined output fires to Format Job Card\n\n  Architectural benefit:\n  This parallel + merge pattern is preserved\n  from v5 because it works well:\n  - Raw data preserved immediately (backup in\n    case AI fails)\n  - AI evaluation runs independently (can fail\n    without losing data)\n  - Merge combines best of both (AI scores +\n    complete job details)\n  - Clean separation of concerns (AI\n    intelligence vs. data preservation)\n  - Visual representation in workflow (easy to\n    understand)\n\n  What happens next:\n  The merged data (AI evaluation + complete job\n  fields) flows to:\n  - Format Job Card: Creates HTML email card\n    using:\n    â€¢ AI scores for badge colors and\n      recommendations\n    â€¢ Job fields for company, title, salary,\n      location display\n    â€¢ _context_workflow_run_id for email queue\n      grouping\n    â€¢ Strengths/weaknesses/mismatches for\n      detailed assessment\n"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================================\n// NODE 7: FORMAT JOB CARD (COMPACT HTML GENERATOR)\n// Purpose: Create compact, professional HTML card for each job\n// Input: Single merged job (with AI evaluation + raw Apify data)\n// Output: Formatted HTML card + metadata for database/sorting\n// ============================================================================\n\n// This node receives the COMPLETE job data from Merge node:\n// - All AI evaluation fields (scores, recommendation, reasoning)\n// - All raw Apify fields (title, company, salary, location, description)\n// - All context fields (workflow_run_id, company_id, etc.)\n\nconst job = $json;\n\n// ============================================================================\n// HELPER FUNCTIONS\n// These functions safely extract and format job data with fallbacks\n// ============================================================================\n\n// FORMAT SALARY DISPLAY\n// Handles missing data, different currencies, and ranges\nconst formatSalary = () => {\n  const min = job.ai_salary_minvalue || job.salary_min;\n  const max = job.ai_salary_maxvalue || job.salary_max;\n  const currency = job.ai_salary_currency || job.salary_currency || 'USD';\n  \n  if (!min && !max) return 'Not specified';\n  \n  const formatNum = (num) => {\n    if (!num) return '';\n    const formatted = parseInt(num).toLocaleString();\n    return currency === 'USD' ? `$${formatted}` : `${formatted} ${currency}`;\n  };\n  \n  if (min && max) return `${formatNum(min)} - ${formatNum(max)}`;\n  return formatNum(min || max);\n};\n// Example outputs:\n// - \"$200,000 - $250,000\" (full range)\n// - \"$200,000\" (min only)\n// - \"Not specified\" (no data)\n\n// FORMAT LOCATION DISPLAY\n// Prioritizes most reliable location data sources\nconst formatLocation = () => {\n  const parts = [];\n  \n  // PRIORITY 1: Try ai_remote_location array (most reliable for remote/hybrid)\n  if (job.ai_remote_location && Array.isArray(job.ai_remote_location) && job.ai_remote_location.length > 0) {\n    // Take first location, or show count if multiple\n    if (job.ai_remote_location.length === 1) {\n      parts.push(job.ai_remote_location[0]);\n    } else {\n      parts.push(`${job.ai_remote_location[0]} (+${job.ai_remote_location.length - 1} more)`);\n    }\n  } \n  // PRIORITY 2: Try locations_raw structure\n  else if (job.locations_raw?.[0]?.address?.addressLocality) {\n    const loc = job.locations_raw[0].address.addressLocality;\n    // If it's a concatenated string with |, take first location\n    parts.push(loc.includes('|') ? loc.split('|')[0].trim() : loc);\n  }\n  // PRIORITY 3: Try locations_derived or cities_derived\n  else if (job.locations_derived?.[0]) {\n    parts.push(job.locations_derived[0]);\n  } else if (job.cities_derived?.[0]) {\n    const city = job.cities_derived[0];\n    const region = job.regions_derived?.[0];\n    parts.push(region && region !== city ? `${city}, ${region}` : city);\n  }\n  \n  // Add work arrangement with emoji\n  if (job.remote_derived === true || job.remote_derived === 'true') {\n    parts.push('ğŸ  Remote');\n  } else if (job.ai_work_arrangement) {\n    parts.push(`ğŸ“ ${job.ai_work_arrangement}`);\n  }\n  \n  return parts.length ? parts.join(' â€¢ ') : 'Location not specified';\n};\n// Example outputs:\n// - \"San Francisco, CA â€¢ ğŸ  Remote\"\n// - \"New York (+2 more) â€¢ ğŸ“ Hybrid\"\n\n// GET BADGE COLOR BY RECOMMENDATION\n// Maps recommendation to color-coded badge\nconst getBadgeColor = (rec) => {\n  const colors = {\n    'EXCELLENT_MATCH': '#10b981',  // Green\n    'GOOD_MATCH': '#3b82f6',       // Blue\n    'CONSIDER': '#f59e0b',         // Amber\n    'POOR_FIT': '#ef4444',         // Red\n    'REJECT': '#991b1b',           // Dark red\n    'UNKNOWN': '#6b7280'           // Gray\n  };\n  return colors[rec] || '#6b7280';\n};\n\n// FORMAT ARRAY AS LIST ITEMS\n// Safely converts arrays to HTML list items\nconst formatList = (arr) => {\n  if (!arr || !Array.isArray(arr) || arr.length === 0) return '';\n  return arr.map(item => `<li style=\"margin-bottom: 3px;\">${item}</li>`).join('');\n};\n\n// SAFELY GET RECOMMENDATION AND SCORE\n// Multiple fallback paths to ensure we always have values\nconst recommendation = job.recommendation || job.ai_evaluation?.recommendation || 'UNKNOWN';\nconst overallScore = job.overall_score || job.ai_evaluation?.overall_score || 0;\n\n// ============================================================================\n// BUILD COMPACT HTML CARD\n// Professional, responsive design optimized for email clients\n// ============================================================================\n\nconst htmlCard = `\n<div style=\"margin-bottom: 0; padding: 16px; border: 1px solid #e5e7eb; border-radius: 8px; background: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\">\n  \n  <!-- Header: Title, Company, Badge -->\n  <div style=\"display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px; flex-wrap: wrap; gap: 10px;\">\n    <div style=\"flex: 1; min-width: 250px;\">\n      <h2 style=\"margin: 0 0 4px 0; color: #111827; font-size: 18px; font-weight: 600; line-height: 1.3;\">\n        ${job.title || job.job_title || 'Position Title Not Available'}\n      </h2>\n      <p style=\"margin: 0; color: #6b7280; font-size: 14px;\">\n        ${job.organization || job.company_name || 'Company Not Specified'}\n      </p>\n    </div>\n    <div style=\"background: ${getBadgeColor(recommendation)}; color: white; padding: 6px 12px; border-radius: 6px; font-size: 13px; font-weight: 600; white-space: nowrap; text-align: center;\">\n      <div style=\"font-size: 16px; margin-bottom: 2px;\">${overallScore}/10</div>\n      <div style=\"font-size: 10px; opacity: 0.9;\">${recommendation.replace(/_/g, ' ')}</div>\n    </div>\n  </div>\n\n  <!-- Compact Details + Scores Grid -->\n  <div style=\"margin-bottom: 12px; padding: 12px; background: #f9fafb; border-radius: 6px; border-left: 3px solid ${getBadgeColor(recommendation)};\">\n    \n    <!-- Two Column Layout for Details -->\n    <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px; margin-bottom: 10px; font-size: 13px;\">\n      <div>\n        <strong style=\"color: #374151;\">ğŸ’° Comp:</strong> \n        <span style=\"color: #111827;\">${formatSalary()}</span>\n      </div>\n      <div>\n        <strong style=\"color: #374151;\">ğŸ“Š Level:</strong> \n        <span style=\"color: #111827;\">${job.ai_experience_level || job.experience_level || 'Not specified'}</span>\n      </div>\n      <div>\n        <strong style=\"color: #374151;\">ğŸ“ Location:</strong> \n        <span style=\"color: #111827;\">${formatLocation()}</span>\n      </div>\n      <div>\n        <strong style=\"color: #374151;\">ğŸ“… Posted:</strong> \n        <span style=\"color: #111827;\">${job.date_posted ? new Date(job.date_posted).toLocaleDateString() : 'Recently'}</span>\n      </div>\n    </div>\n\n    <!-- Apply Link -->\n    <div style=\"font-size: 13px; padding-top: 8px; border-top: 1px solid #e5e7eb;\">\n      <strong style=\"color: #374151;\">ğŸ”— Apply:</strong> \n      <a href=\"${job.url || job.job_url || '#'}\" style=\"color: #3b82f6; text-decoration: none;\" target=\"_blank\">View Job Posting â†’</a>\n    </div>\n\n    <!-- Inline Scores (Compact) -->\n    <div style=\"margin-top: 10px; padding-top: 10px; border-top: 1px solid #e5e7eb;\">\n      <div style=\"display: flex; justify-content: space-between; align-items: center; font-size: 11px;\">\n        <span style=\"color: #6b7280; font-weight: 600;\">SCORES:</span>\n        <div style=\"display: flex; gap: 10px;\">\n          <span style=\"color: #374151;\"><strong>Senior:</strong> ${job.seniority_match || 0}</span>\n          <span style=\"color: #374151;\"><strong>Domain:</strong> ${job.domain_match || 0}</span>\n          <span style=\"color: #374151;\"><strong>Tech:</strong> ${job.technical_depth || 0}</span>\n          <span style=\"color: #374151;\"><strong>Loc:</strong> ${job.location_fit || 0}</span>\n          <span style=\"color: #374151;\"><strong>Comp:</strong> ${job.compensation_fit || 0}</span>\n        </div>\n      </div>\n    </div>\n\n  </div>\n\n  <!-- AI Match Explanation -->\n  ${job.match_explanation ? `\n  <div style=\"margin-bottom: 10px;\">\n    <strong style=\"color: #374151; display: block; margin-bottom: 6px; font-size: 13px;\">âœ¨ AI Assessment:</strong>\n    <p style=\"margin: 0; color: #4b5563; font-size: 12px; line-height: 1.5; padding: 8px; background: #fefce8; border-radius: 4px; border-left: 3px solid #fbbf24;\">\n      ${job.match_explanation}\n    </p>\n  </div>\n  ` : ''}\n\n  <!-- Strengths -->\n  ${job.strengths && Array.isArray(job.strengths) && job.strengths.length > 0 ? `\n  <div style=\"margin-bottom: 10px;\">\n    <strong style=\"color: #10b981; display: block; margin-bottom: 4px; font-size: 13px;\">âœ… Strengths:</strong>\n    <ul style=\"margin: 0; padding-left: 20px; color: #4b5563; font-size: 12px; line-height: 1.4;\">\n      ${formatList(job.strengths)}\n    </ul>\n  </div>\n  ` : ''}\n\n  <!-- Weaknesses/Concerns -->\n  ${job.weaknesses && Array.isArray(job.weaknesses) && job.weaknesses.length > 0 ? `\n  <div style=\"margin-bottom: 10px;\">\n    <strong style=\"color: #f59e0b; display: block; margin-bottom: 4px; font-size: 13px;\">âš ï¸ Considerations:</strong>\n    <ul style=\"margin: 0; padding-left: 20px; color: #4b5563; font-size: 12px; line-height: 1.4;\">\n      ${formatList(job.weaknesses)}\n    </ul>\n  </div>\n  ` : ''}\n\n  <!-- Key Mismatches -->\n  ${job.key_mismatches && Array.isArray(job.key_mismatches) && job.key_mismatches.length > 0 ? `\n  <div>\n    <strong style=\"color: #ef4444; display: block; margin-bottom: 4px; font-size: 13px;\">ğŸš« Mismatches:</strong>\n    <ul style=\"margin: 0; padding-left: 20px; color: #4b5563; font-size: 12px; line-height: 1.4;\">\n      ${formatList(job.key_mismatches)}\n    </ul>\n  </div>\n  ` : ''}\n\n</div>\n`;\n\n// ============================================================================\n// OUTPUT STRUCTURE\n// Compact database row with embedded HTML card\n// ============================================================================\n\nreturn [{\n  json: {\n    // === CORE IDENTIFIERS ===\n    // Multiple fallback paths to ensure we always have IDs\n    job_id: job.job_id || job.id,\n    company_id: job.company_id || job._context_company_id || 'unknown',\n    company_name: job.organization || job.company_name,\n    \n    // === SORTING FIELDS ===\n    // Email workflow will sort by overall_score DESC\n    recommendation: recommendation,\n    overall_score: overallScore,\n    \n    // === HTML CARD FOR EMAIL ===\n    // Complete, self-contained HTML card\n    // Can be directly inserted into email body\n    html_card: htmlCard,\n    \n    // === KEY DETAILS FOR DATABASE REFERENCE ===\n    // Minimal searchable fields (HTML card has complete details)\n    job_title: job.title || job.job_title,\n    job_url: job.url || job.job_url,\n    salary_min: job.ai_salary_minvalue || job.salary_min,\n    salary_max: job.ai_salary_maxvalue || job.salary_max,\n    location: formatLocation(),\n    date_posted: job.date_posted,\n\n    // === WORKFLOW TRACKING ===\n    // CRITICAL: workflow_run_id links all jobs from this workflow run\n    // Email workflow will query: \"SELECT * WHERE workflow_run_id = X\"\n    workflow_run_id: job._context_workflow_run_id || $execution.id,\n    \n    // === TIMESTAMP ===\n    processed_at: new Date().toISOString()\n  }\n}];\n\n// WHY EMBED HTML IN DATABASE?\n// Alternative approaches:\n// 1. Store job fields + generate HTML in email workflow\n//    - Requires duplicating formatting logic\n//    - Email workflow becomes complex\n//    \n// 2. Store HTML card (current approach)\n//    - Format once, use everywhere\n//    - Email workflow stays simple\n//    - Can preview cards in database\n//    - Consistent formatting guaranteed\n//    \n// Tradeoff: Larger database rows, but much simpler email generation\n\n// DATABASE SCHEMA EFFICIENCY:\n// Instead of storing 30+ job fields separately:\n// - job_id, company_name, recommendation, overall_score (searchable)\n// - html_card (complete formatted output)\n// - workflow_run_id (for querying by run)\n// \n// Advantages:\n// - Simple queries\n// - No complex joins\n// - Fast email generation\n// - Self-contained cards\n\n// Next node: Save to Email Queue\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        288
      ],
      "id": "c9a29246-e573-45ca-a0a3-daf6ad52d40a",
      "name": "Format Job Card",
      "notes": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  NODE 6: FORMAT JOB CARD (COMPACT HTML\n  GENERATOR)  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  Purpose: Create compact, professional HTML\n  card for each job\n  Input: Single merged job (with AI evaluation +\n  raw Apify data + context fields)\n  Output: Formatted HTML card + metadata for\n  database/sorting\n\n  The node output includes:\n  - Helper functions (formatSalary,\n    formatLocation, getBadgeColor, etc.)\n  - HTML card generation with responsive design\n  - Color-coded badges based on recommendation\n  - Detailed scoring display\n  - AI assessment sections (strengths,\n    weaknesses, mismatches)\n  - Output structure for database insertion\n\n  Next node: Save to Email Queue"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "8Z8MLvTvK4YX7SuB",
          "mode": "list",
          "cachedResultName": "Email_Queue",
          "cachedResultUrl": "/projects/NRVzB7ls7lOjZ60v/datatables/8Z8MLvTvK4YX7SuB"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "workflow_run_id": "={{ $json.workflow_run_id }}",
            "recommendation": "={{ $json.recommendation }}",
            "overall_score": "={{ $json.overall_score }}",
            "html_card": "={{ $json.html_card }}",
            "job_id": "={{ $json.job_id }}",
            "company_name": "={{ $json.company_name }}",
            "job_title": "={{ $json.job_title }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "workflow_run_id",
              "displayName": "workflow_run_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "recommendation",
              "displayName": "recommendation",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "overall_score",
              "displayName": "overall_score",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "html_card",
              "displayName": "html_card",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "job_id",
              "displayName": "job_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "company_name",
              "displayName": "company_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "job_title",
              "displayName": "job_title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "optimizeBulk": false
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        1552,
        288
      ],
      "id": "a191b21d-1a34-4f0e-82ac-e193e054c010",
      "name": "Insert email row",
      "notes": "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  NODE 7: SAVE TO EMAIL QUEUE DATABASE  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  Inserts formatted job card into the\n  'email_queue' table for later aggregation.\n\n  Next node: Loop Over Jobs (loops back for next\n  job in current company)\n"
    }
  ],
  "pinData": {},
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "Loop Over Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Jobs": {
      "main": [
        [
          {
            "node": "Workflow Complete",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Workflow Complete": {
      "main": [
        []
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Format Job Card",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Job Card": {
      "main": [
        [
          {
            "node": "Insert email row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert email row": {
      "main": [
        [
          {
            "node": "Loop Over Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "e2d4d8aa-4b25-4032-9871-b6d14ffdb995",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "b50b11e8b95a97f785a59928b1142bfe5660398bf6359dbc9cca38ca2424c956"
  },
  "id": "opBrfNaudhVTNj6p",
  "tags": []
}