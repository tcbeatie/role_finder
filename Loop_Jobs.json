{
  "name": "Loop Jobs v3.1 - FULLY DOCUMENTED",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -480,
        96
      ],
      "id": "dc5ad096-9aaf-410d-85bc-1070aba7976c",
      "name": "Start",
      "COMMENT": "═══════════════════════════════════════════════════════════════════════════\nNODE 1: WORKFLOW TRIGGER (SUB-WORKFLOW ENTRY POINT)\n═══════════════════════════════════════════════════════════════════════════\nThis is the entry point for the Job workflow, which is called as a \nSUB-WORKFLOW from the parent \"Loop Companies v2.1\" workflow.\n\nHow this workflow gets triggered:\n1. Manual execution: Click \"Execute workflow\" button in n8n UI for testing\n2. Sub-workflow call: Parent workflow calls this via Execute Workflow node\n   - Parent passes job data with _context_ fields\n   - This workflow processes jobs independently\n   - Returns control to parent when complete\n\nWhat data arrives here (FROM PARENT WORKFLOW v2.1):\nWhen called from parent workflow, receives job items with:\n\n=== APIFY JOB FIELDS ===\n- id: Apify's unique job identifier\n- title: Job title (\"Senior Technical Product Manager\")\n- organization: Company name (\"Anthropic\")\n- salary fields: ai_salary_minvalue, ai_salary_maxvalue, ai_salary_currency\n- location fields: locations_raw, remote_derived, ai_work_arrangement\n- description_text: Full job description\n- url: Link to apply\n- date_posted: When job was posted\n- experience_level: Apify's AI-extracted experience level\n... and many more Apify fields\n\n=== COMPANY CONTEXT FIELDS ===\n- _context_workflow_run_id: Parent workflow's execution ID\n- _context_company_id: Company identifier (\"anthropic\")\n- _context_company_name: Company display name (\"Anthropic\")\n- _context_domain: Company domain (\"anthropic.com\")\n\n=== PROFILE CONTEXT FIELDS (NEW IN v3.1) ===\nThese are added by parent workflow's \"Add Context\" node:\n- _context_profile_id: Candidate profile identifier (\"ted_beatie_pm\")\n- _context_resume_text: Complete resume/experience text for AI evaluation\n- _context_target_criteria: Job search criteria JSON\n\nARCHITECTURAL EVOLUTION:\n\nv5 (OLD - Nested Architecture):\n- Job processing nested inside company loop\n- Profile HARDCODED in \"Add Resume Context\" node in this workflow\n- 60+ lines of hardcoded resume text in workflow JSON\n- Multi-user support impossible\n- Profile updates require workflow edits\n\nv3.1 (NEW - Externalized Profile):\n- Job processing in separate sub-workflow\n- Profile passed via _context_resume_text from parent\n- No hardcoded personal data in workflow JSON\n- Multi-user ready (different profiles per run)\n- Profile updates don't require workflow changes\n- \"Add Resume Context\" node removed entirely (no longer needed!)\n\nWhy v3.1 architecture is better:\n1. NO HARDCODED DATA: Workflow is profile-agnostic\n2. MULTI-USER READY: Different users can have different profiles\n3. TESTING FRIENDLY: Can test with different profiles without editing workflow\n4. SEPARATION OF CONCERNS: Parent handles profile, this workflow handles evaluation\n5. REUSABILITY: Same workflow can evaluate jobs for any candidate\n6. SIMPLER FLOW: One less node to maintain\n7. VERSION CONTROL: Workflow JSON contains no personal information\n8. SECURITY: Profile can be stored encrypted in database\n\nData flow visualization:\nStart (receives jobs with _context_resume_text) →\n  Loop Over Jobs (one job at a time) →\n    PARALLEL SPLIT:\n      Path A: Message a model (AI uses _context_resume_text) → Parse → Merge\n      Path B: Direct to Merge (preserves raw data) →\n    MERGE → Format Job Card → Save to Email Queue → Loop back\n\nWorkflow purpose:\nProcess jobs ONE AT A TIME through:\n1. Loop Over Jobs: Iterate through jobs (fault tolerance)\n2. Message a model: AI evaluation with Claude Sonnet 4.5 using _context_resume_text\n3. Parse AI Response: Extract and structure evaluation\n4. Merge: Combine AI evaluation with raw job data (parallel paths)\n5. Format Job Card: Generate HTML email card\n6. Save to Email Queue: Store for email aggregation\n\nKey improvement from v5:\nThe \"Add Resume Context\" node has been ELIMINATED. Since parent workflow\nalready provides _context_resume_text in the job data, we can use it directly\nin the AI prompt without needing a separate transformation node.\n\nNext node: Loop Over Jobs\n═══════════════════════════════════════════════════════════════════════════"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -224,
        96
      ],
      "id": "928d0894-d3c1-47c5-8ae9-1f710a94ec67",
      "name": "Loop Over Jobs",
      "COMMENT": "═══════════════════════════════════════════════════════════════════════════\nNODE 2: LOOP OVER JOBS (JOB PROCESSING ORCHESTRATOR)\n═══════════════════════════════════════════════════════════════════════════\nProcesses jobs ONE AT A TIME using a loop pattern.\n\nWhat is this loop doing?\n- Takes array of jobs passed from parent workflow (e.g., 8 jobs from Anthropic)\n- Each job already includes _context_ fields with profile data\n- Processes each job individually through AI evaluation\n- Batch size: 1 (default) means one job per loop iteration\n\nWhy loop over jobs individually?\n1. AI API RATE LIMITING: Avoid overwhelming Claude API with parallel requests\n2. COST TRACKING: Know exact number of AI calls and costs\n3. PROGRESS MONITORING: See real-time progress through jobs\n4. ERROR ISOLATION: If job #5 fails, jobs #6-8 still process\n5. SEQUENTIAL EVALUATION: Each job gets full AI attention\n6. BUDGET CONTROL: Can stop mid-run if needed\n\nHow the loop works:\n┌─ Loop iteration 1: Job 1 (\"Senior PM at Anthropic\")\n│  ├─ Split to AI path + raw data path (parallel)\n│  ├─ AI Evaluation → Parse → Merge\n│  ├─ Raw data → Merge\n│  ├─ Format → Save to email queue\n│  └─ Return to loop node\n│\n├─ Loop iteration 2: Job 2 (\"Lead PM at Anthropic\")\n│  ├─ Same parallel processing\n│  └─ Return to loop node\n│\n└─ All jobs done → Done branch activates\n\nTwo outputs (pins on the node):\n1. DONE BRANCH (top pin):\n   - Fires ONCE after ALL jobs for current company complete\n   - Routes to: Workflow Complete\n   - Signals to parent workflow: \"All jobs processed, ready for next company\"\n   \n2. LOOP BRANCH (bottom pin):\n   - Fires ONCE PER JOB\n   - Routes to TWO nodes in parallel:\n     • Message a model (AI evaluation path)\n     • Merge (raw data preservation path)\n   - This parallel split is key to the architecture\n\nAccessing current job in downstream nodes:\n$('Loop Over Jobs').item.json\n// This gives you the current job being processed\n// Includes ALL fields from parent workflow:\n// {\n//   id: \"12345\",\n//   title: \"Senior PM\",\n//   description_text: \"...\",\n//   _context_workflow_run_id: 67890,\n//   _context_company_id: \"anthropic\",\n//   _context_company_name: \"Anthropic\",\n//   _context_resume_text: \"TED BEATIE - PRODUCT LEADER...\",  // NEW IN v3.1\n//   _context_target_criteria: \"{...}\",                        // NEW IN v3.1\n//   _context_profile_id: \"ted_beatie_pm\",                     // NEW IN v3.1\n//   ... all other Apify fields\n// }\n\nProfile context availability (v3.1):\nEVERY job in the loop has access to:\n- _context_resume_text: Full resume for AI evaluation (used in Message a model)\n- _context_target_criteria: Search criteria (for reference/future use)\n- _context_profile_id: Profile identifier (for tracking)\n\nThis eliminates the need for:\n- Hardcoded profile in workflow JSON\n- \"Add Resume Context\" transformation node\n- Profile loading from database in this workflow\n- Multiple copies of profile data across workflows\n\nParallel processing pattern:\nAfter Loop Over Jobs, the job data flows to TWO destinations simultaneously:\n\nPath A (AI Evaluation - Slow):\n└─ Message a model (2-5 seconds, costs $0.003)\n   └─ Parse AI Response\n      └─ Merge (input 0)\n\nPath B (Raw Data - Fast):\n└─ Merge (input 1, instant, free)\n\nWhy both paths?\n- Path A: Gets AI intelligence and scoring\n- Path B: Preserves complete job data\n- Merge: Combines AI evaluation with raw job fields\n- Result: Job with BOTH AI scores AND all original details\n\nTiming example:\nIf Anthropic has 8 jobs:\n- Loop executes 8 times (once per job)\n- Each iteration: 2-5 seconds for AI evaluation\n- Total: 16-40 seconds for all 8 jobs\n- Then Done branch fires once\n- Parent workflow continues to next company\n\nKey architectural difference from v5:\nOLD (v5): \n- This was the INNER loop nested inside company loop\n- Both loops in same workflow (complex)\n- Profile hardcoded in \"Add Resume Context\" node\n- Three nodes: Add Resume Context → Split → AI + Raw paths\n     \nNEW (v3.1):\n- This is the ONLY loop in this workflow (simple)\n- Company loop is in parent workflow (separation)\n- Profile arrives via _context_resume_text (externalized)\n- Two parallel paths directly from loop (no intermediate node)\n- \"Add Resume Context\" node eliminated entirely\n\nArchitectural improvement:\nRemoving \"Add Resume Context\" simplifies the workflow because:\n1. Profile data already present in job (from parent)\n2. No transformation needed (direct usage in AI prompt)\n3. One less node to test and maintain\n4. Clearer data flow visualization\n5. Fewer potential failure points\n\nLoop-back path:\nSave to Email Queue → Loop Over Jobs → (next job iteration)\n\nWhen all jobs complete:\nLoop Over Jobs (Done) → Workflow Complete → Return to parent\n\nNext nodes (PARALLEL):\n- Loop branch (AI path) → Message a model\n- Loop branch (Raw path) → Merge (input 1)\n═══════════════════════════════════════════════════════════════════════════"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "claude-sonnet-4-5-20250929"
        },
        "messages": {
          "values": [
            {
              "content": "=Candidate Profile:\n{{ $json._context_resume_text }}\n\nJob Details:\n- Job ID: {{ $json.id }}\n- Title: {{ $json.title }}\n- Company: {{ $json.organization }}\n- Location: {{ $json.locations_derived || $json.location_locality }}, {{ $json.regions_derived || $json.location_region }} (Remote: {{ $json.remote_derived }})\n- Work Arrangement: {{ $json.ai_work_arrangement }}\n- Salary: {{ $json.ai_salary_minvalue }} - {{ $json.ai_salary_maxvalue }} {{ $json.ai_salary_currency }}\n- Experience Level: {{ $json.ai_experience_level }}\n- URL: {{ $json.url }}\n\nJob Description:\n{{ $json.description_text }}\n\nEvaluate this job against the candidate's profile and return ONLY valid JSON with this exact structure:\n\n{\n  \"job_id\": \"{{ $json.id }}\",\n  \"overall_score\": <number 1-10>,\n  \"recommendation\": \"<EXCELLENT_MATCH|GOOD_MATCH|CONSIDER|POOR_FIT|REJECT>\",\n  \"detailed_scores\": {\n    \"seniority_match\": <number 1-10>,\n    \"domain_match\": <number 1-10>,\n    \"technical_depth\": <number 1-10>,\n    \"location_fit\": <number 1-10>,\n    \"compensation\": <number 1-10>\n  },\n  \"reasoning\": {\n    \"strengths\": [<array of 3-6 specific strengths>],\n    \"weaknesses\": [<array of key concerns or gaps>],\n    \"key_mismatches\": [<array of critical misalignments if any>]\n  },\n  \"match_explanation\": \"<2-4 sentence summary explaining the overall assessment>\"\n}\n\nCRITICAL: You must include \"job_id\": \"{{ $json.id }}\" as the first field in your JSON response.\n\nScoring criteria:\n- Seniority: Senior/Lead/Principal/Director level roles (not Associate/Junior)\n- Domain: Infrastructure, Platform Engineering, Developer Experience, API platforms, Cloud systems\n- Technical Depth: Backend systems, integrations, developer tools expertise required\n- Location: Remote, Hybrid NYC Metro, or Hybrid Bay Area (10=perfect, 0=dealbreaker)\n- Compensation: $190k+ is threshold (10 if well above, 0 if below)\n\nReturn only the JSON, no markdown formatting."
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.anthropic",
      "typeVersion": 1,
      "position": [
        256,
        96
      ],
      "id": "460120ee-2704-4ffe-a26a-57d0b7526513",
      "name": "Message a model",
      "COMMENT": "═══════════════════════════════════════════════════════════════════════════\nNODE 3: AI JOB EVALUATION (CLAUDE SONNET 4.5)\n═══════════════════════════════════════════════════════════════════════════\nSends job + candidate profile to Claude AI for intelligent evaluation.\n\nARCHITECTURAL CHANGE (v3.1):\nThis node now directly accesses {{ $json._context_resume_text }} from the\njob data passed by parent workflow. No intermediate \"Add Resume Context\" node\nis needed, simplifying the architecture.\n\nWhat this node does:\nCalls Anthropic's Claude API with:\n1. Complete candidate profile via _context_resume_text (from parent workflow)\n2. Full job details (title, company, salary, location, description)\n3. Structured evaluation prompt with scoring dimensions\n\nAI Model: claude-sonnet-4-5-20250929\n- Anthropic's Claude Sonnet 4.5 model\n- Fast, high-quality reasoning\n- Excellent at structured output (JSON)\n- Strong at comparative analysis\n- Optimized for tool use and long-context understanding\n\nPrompt structure breakdown:\n\n=== SECTION 1: CANDIDATE PROFILE ===\n{{ $json._context_resume_text }}\n\nKEY ARCHITECTURAL NOTE (v3.1):\nThis template variable directly accesses the resume text that was added to\nthe job data by the parent workflow's \"Add Context\" node. This eliminates\nthe need for a separate \"Add Resume Context\" node in this workflow.\n\nThe _context_resume_text field contains the complete candidate profile:\n- Professional summary\n- Key achievements\n- Technical expertise\n- Recent experience (detailed)\n- Target role criteria\n- Ideal fit indicators\n\n=== SECTION 2: JOB DETAILS ===\nAll relevant job fields extracted from Apify data:\n- {{ $json.id }}: Unique job identifier (critical for merge)\n- {{ $json.title }}: Job title\n- {{ $json.organization }}: Company name\n- {{ $json.locations_derived }}: Location information\n- {{ $json.ai_salary_minvalue }}: Salary range\n- {{ $json.description_text }}: Full job description\n\n=== SECTION 3: EVALUATION STRUCTURE ===\nPrompt instructs AI to return JSON with:\n\n1. OVERALL ASSESSMENT:\n   - overall_score: 1-10 rating\n   - recommendation: EXCELLENT_MATCH | GOOD_MATCH | CONSIDER | POOR_FIT | REJECT\n   - match_explanation: 2-4 sentence summary\n\n2. DETAILED SCORES (5 dimensions, each 1-10):\n   - seniority_match: Is this Senior/Lead/Principal/Director level?\n   - domain_match: Infrastructure/Platform/DevEx/API/Cloud focus?\n   - technical_depth: Backend systems/integrations/developer tools?\n   - location_fit: Remote, Hybrid NYC Metro, or Hybrid Bay Area?\n   - compensation: Meets $190k+ threshold?\n\n3. REASONING:\n   - strengths: 3-6 specific reasons this job is a good fit\n   - weaknesses: Key concerns or gaps\n   - key_mismatches: Critical dealbreakers (if any)\n\nWhy include job_id in AI response?\nCRITICAL: The job_id field is explicitly requested in the prompt template.\nThis ensures the AI's response can be matched back to the original job\nin the Merge node. The Merge node uses:\n- AI response: job_id field\n- Raw job data: id field\nThese must match for proper merging.\n\nExample AI input:\n\"Candidate Profile:\nTED BEATIE - PRODUCT LEADER\n- 15+ years Technical Product Management...\n[full resume]\n\nJob Details:\n- Job ID: 12345\n- Title: Senior Technical Product Manager\n- Company: Anthropic\n- Salary: $200,000 - $250,000 USD\n- Location: San Francisco, CA (Remote: true)\n- Description: We are looking for...\n[full description]\n\nEvaluate this job...\"\n\nExample AI output:\n{\n  \"job_id\": \"12345\",\n  \"overall_score\": 9,\n  \"recommendation\": \"EXCELLENT_MATCH\",\n  \"detailed_scores\": {\n    \"seniority_match\": 10,\n    \"domain_match\": 9,\n    \"technical_depth\": 8,\n    \"location_fit\": 10,\n    \"compensation\": 9\n  },\n  \"reasoning\": {\n    \"strengths\": [\n      \"Senior-level role matches 15+ years experience perfectly\",\n      \"Heavy API and infrastructure focus aligns with Travelport/SANS background\",\n      \"Remote position eliminates location concerns\",\n      \"Compensation well above $190k threshold\",\n      \"Company culture emphasizes technical depth over breadth\"\n    ],\n    \"weaknesses\": [\n      \"May require more ML/AI expertise than currently possessed\",\n      \"Fast-paced startup environment could be demanding\"\n    ],\n    \"key_mismatches\": []\n  },\n  \"match_explanation\": \"This is an excellent match. The role's focus on technical infrastructure and API platforms directly aligns with experience building integrations at Travelport and provisioning systems at SANS. The senior level, remote work, and strong compensation make this an ideal opportunity.\"\n}\n\nCost analysis:\n- Input tokens: ~2,500 tokens (full profile + full job description)\n- Output tokens: ~500 tokens (structured evaluation)\n- Cost per evaluation: ~$0.003 per job\n- Daily cost (40 companies × 3 jobs avg): 120 jobs × $0.003 = $0.36/day\n- Monthly cost: ~$11/month for AI evaluation\n- ROI: $11/month for intelligent job screening vs. manual review time\n\nTiming:\n- API latency: 2-5 seconds per job (depends on job description length)\n- Parallel processing: NO (sequential loop prevents API throttling)\n- For 8 Anthropic jobs: 16-40 seconds total\n\nError handling:\n- If AI fails: Error passed to downstream nodes\n- n8n catches errors in execution log\n- Could implement retry logic for transient failures\n- Parse node validates JSON structure downstream\n\nWhy this is the \"slow path\":\nCompared to the parallel \"raw data\" path that goes directly to Merge:\n- AI path (this node): 2-5 seconds per job, costs $0.003\n- Raw path (parallel): Instant, free\n\nBoth paths are necessary:\n- AI path provides intelligence and evaluation (this node → Parse → Merge input 0)\n- Raw path preserves complete job data (direct to Merge input 1)\n- Merge combines both for complete job+evaluation object\n\nProfile externalization benefit (v3.1):\nBEFORE: Profile hardcoded in separate \"Add Resume Context\" node\n- 60+ lines of hardcoded resume text\n- Profile updates require editing two places (node + prompt)\n- Multi-user support impossible\n- Personal data in workflow JSON\n\nAFTER: Profile accessed via {{ $json._context_resume_text }}\n- Single source of truth (parent workflow's Add Context node)\n- Profile updates only need database change\n- Multi-user ready (different profiles per execution)\n- No personal data in this workflow's JSON\n\nProduction considerations:\n1. RATE LIMITING: Sequential processing avoids API throttling\n2. COST MONITORING: Track usage via Anthropic dashboard\n3. QUALITY CHECKS: Validate AI responses are well-structured\n4. A/B TESTING: Could test different prompts or scoring criteria\n5. CACHING: Could cache evaluations for identical jobs (future enhancement)\n6. PROMPT TUNING: Adjust scoring criteria based on false positives/negatives\n\nNext node: Parse AI Response\n═══════════════════════════════════════════════════════════════════════════",
      "credentials": {
        "anthropicApi": {
          "id": "S1ab7OjjV3CoEjxw",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================================================\n// NODE 4: PARSE AI RESPONSE\n// Extracts and structures AI evaluation from Claude's JSON response\n// ============================================================================\n\n// THE PROBLEM:\n// Claude returns its evaluation in a specific format:\n// $json.content[0].text contains the actual JSON string\n// We need to:\n// 1. Extract the JSON string\n// 2. Clean up any markdown formatting\n// 3. Parse into JavaScript object\n// 4. Restructure for database and merge compatibility\n\n// STEP 1: Extract raw response text from Claude's response structure\nlet response = $json.content[0].text;\n// Example: \"```json\\n{...}\\n```\" or \"{...}\"\n\n// STEP 2: Clean up markdown code fences if present\n// Claude sometimes wraps JSON in markdown code blocks\n// Remove: ```json at start and ``` at end\nresponse = response.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n// Now we have clean JSON string: \"{...}\"\n\n// STEP 3: Parse JSON string into JavaScript object\nconst evaluation = JSON.parse(response);\n// If parsing fails, this will throw an error (caught by n8n error handling)\n\n// STEP 4: Restructure into standardized format\nreturn [{\n  json: {\n    // === CRITICAL: Extract job_id for merge matching ===\n    // This MUST match the job ID from the raw job data\n    // The Merge node uses this to link AI evaluation to correct job\n    job_id: evaluation.job_id,\n    \n    // === Full evaluation object for reference ===\n    // Store complete AI response in case we need it later\n    // Useful for debugging or future analysis\n    ai_evaluation: evaluation,\n    \n    // === Top-level fields for easy access ===\n    // Extract commonly-used fields to top level\n    // Makes downstream formatting easier\n    overall_score: evaluation.overall_score,\n    recommendation: evaluation.recommendation,\n    \n    // === Reasoning details ===\n    // Extract arrays from nested reasoning object\n    // Use || [] to provide empty array fallback if field missing\n    // This prevents errors in downstream formatting\n    strengths: evaluation.reasoning?.strengths || [],\n    weaknesses: evaluation.reasoning?.weaknesses || [],\n    key_mismatches: evaluation.reasoning?.key_mismatches || [],\n    match_explanation: evaluation.match_explanation || '',\n    \n    // === Individual scoring dimensions ===\n    // Extract each score from nested detailed_scores object\n    // Use || 0 to provide default score if field missing\n    seniority_match: evaluation.detailed_scores?.seniority_match || 0,\n    domain_match: evaluation.detailed_scores?.domain_match || 0,\n    technical_depth: evaluation.detailed_scores?.technical_depth || 0,\n    location_fit: evaluation.detailed_scores?.location_fit || 0,\n    compensation_fit: evaluation.detailed_scores?.compensation || 0\n  }\n}];\n\n// WHAT GETS OUTPUT:\n// Flattened, structured evaluation data\n// Example:\n// {\n//   job_id: \"12345\",\n//   ai_evaluation: { <full nested object> },\n//   overall_score: 9,\n//   recommendation: \"EXCELLENT_MATCH\",\n//   strengths: [\"Senior level\", \"Infrastructure focus\", ...],\n//   weaknesses: [\"May require ML expertise\"],\n//   key_mismatches: [],\n//   match_explanation: \"This is an excellent match...\",\n//   seniority_match: 10,\n//   domain_match: 9,\n//   technical_depth: 8,\n//   location_fit: 10,\n//   compensation_fit: 9\n// }\n\n// WHY FLATTEN THE STRUCTURE?\n// 1. EASIER MERGE: Top-level fields merge cleanly with job data\n// 2. DATABASE FRIENDLY: Can map directly to table columns\n// 3. EMAIL FORMATTING: Easy access to scores and arrays\n// 4. BACKUP: Keep full ai_evaluation object for reference\n// 5. QUERY FRIENDLY: Can query by score without parsing JSON\n\n// WHY job_id IS CRITICAL:\n// The Merge node (next step) needs to match this AI evaluation\n// with the corresponding raw job data. It does this by comparing:\n// - AI evaluation (this output): job_id field\n// - Raw job data (parallel path): id field\n// \n// Match logic: WHERE job_id == id\n// \n// If job_id is missing or incorrect:\n// - Merge will fail to find matching pair\n// - AI evaluation gets orphaned\n// - Job card generation breaks\n// - Email doesn't include this job\n\n// ERROR HANDLING:\n// If JSON.parse() fails:\n// - n8n catches error and shows in execution log\n// - Can add try/catch for graceful error handling\n// - Could implement retry logic with different prompt\n// - Could log malformed responses for debugging\n// - Could alert on repeated failures\n\n// VALIDATION CHECKS (could be added for production):\n// - Verify job_id exists and matches expected format\n// - Confirm overall_score is 1-10\n// - Validate recommendation is one of allowed values\n// - Check that required fields are present\n// - Ensure arrays are actually arrays\n// - Validate score ranges (1-10)\n\n// ARCHITECTURAL NOTE:\n// This node completes the \"AI evaluation path\" (Path A).\n// The parsed evaluation now flows to Merge node where it combines\n// with raw job data from the parallel \"raw data path\" (Path B).\n\n// Parallel path recap (v3.1):\n// Path A (AI evaluation - slow path): \n//   Loop Over Jobs → Message a model → Parse AI Response (THIS NODE) → Merge (input 0)\n// \n// Path B (Raw data - fast path):\n//   Loop Over Jobs → Merge (input 1)\n// \n// Note: \"Add Resume Context\" node removed in v3.1\n// Profile data already present via _context_resume_text from parent\n// \n// Merge node receives BOTH:\n// - Input 0: AI evaluation (this node's output)\n// - Input 1: Complete job data with _context_ fields (from Loop Over Jobs)\n// \n// Result: Job with BOTH AI evaluation AND all original job fields\n\n// PRODUCTION MONITORING:\n// Track these metrics:\n// - Parse success rate\n// - Average overall_score (helps calibrate scoring)\n// - Most common recommendations\n// - Frequency of key_mismatches\n// - AI response time trends\n// - Cost per evaluation\n\n// Next node: Merge (input 0)\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        96
      ],
      "id": "75962a70-6a05-41a7-bf43-13336014b8b4",
      "name": "Parse AI Response"
    },
    {
      "parameters": {
        "mode": "combine",
        "advanced": true,
        "mergeByFields": {
          "values": [
            {
              "field1": "job_id",
              "field2": "id"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        784,
        256
      ],
      "id": "650630a5-c548-41d9-aa54-1923ab60fcc0",
      "name": "Merge",
      "COMMENT": "═══════════════════════════════════════════════════════════════════════════\nNODE 5: MERGE AI EVALUATION WITH RAW JOB DATA\n═══════════════════════════════════════════════════════════════════════════\nCombines AI evaluation results with complete job data from Apify.\n\nARCHITECTURAL CHANGE (v3.1):\nInput 1 now comes DIRECTLY from Loop Over Jobs (not from Add Resume Context).\nThis simplifies the data flow since the \"Add Resume Context\" node has been\nremoved. The job data already contains _context_resume_text from parent workflow.\n\nWhat is this node doing?\nThe Merge node receives data from TWO parallel paths and combines them:\n\nINPUT 0 (Top pin - AI evaluation path):\nComes from: Parse AI Response\nContains:\n- job_id: \"12345\" (for matching)\n- overall_score: 9\n- recommendation: \"EXCELLENT_MATCH\"\n- detailed scores: seniority_match, domain_match, etc.\n- reasoning arrays: strengths, weaknesses, key_mismatches\n- match_explanation: AI's summary text\n- ai_evaluation: Full nested evaluation object\n\nINPUT 1 (Bottom pin - Raw job data path):\nComes from: Loop Over Jobs (DIRECT connection in v3.1)\nContains:\n- id: \"12345\" (matches job_id from Input 0)\n- All Apify fields: title, organization, salary, location, description_text\n- All _context_ fields: workflow_run_id, company_id, company_name, domain\n- Profile context fields: _context_resume_text, _context_profile_id, _context_target_criteria\n\nMerge Mode: Combine by Fields\n- Matches items based on specified field pairs\n- Field 1 (from Input 0): job_id\n- Field 2 (from Input 1): id\n- When job_id == id, combine those items into single object\n\nWhy we need both inputs:\n1. AI EVALUATION (Input 0):\n   - Provides intelligence and scoring\n   - But loses original job fields in the process\n   - Claude only returns what we asked for (evaluation JSON)\n   - No job title, company, salary, URL, etc.\n   \n2. RAW JOB DATA (Input 1):\n   - Preserves ALL original Apify fields\n   - Includes _context_ fields for tracking and grouping\n   - Includes _context_resume_text (though not used after AI evaluation)\n   - But has no AI evaluation\n\n3. MERGED OUTPUT:\n   - Best of both worlds\n   - AI scores + Complete job details + Context fields\n   - Everything needed for email formatting\n   - Single comprehensive object per job\n\nExample merge:\n\nINPUT 0 (AI evaluation from Parse AI Response):\n{\n  job_id: \"12345\",\n  overall_score: 9,\n  recommendation: \"EXCELLENT_MATCH\",\n  strengths: [\"Senior level\", \"Infrastructure focus\", \"Remote\"],\n  weaknesses: [\"May require ML expertise\"],\n  key_mismatches: [],\n  seniority_match: 10,\n  domain_match: 9,\n  technical_depth: 8,\n  location_fit: 10,\n  compensation_fit: 9\n}\n\nINPUT 1 (Raw job from Loop Over Jobs):\n{\n  id: \"12345\",\n  title: \"Senior Technical Product Manager\",\n  organization: \"Anthropic\",\n  ai_salary_minvalue: 200000,\n  ai_salary_maxvalue: 250000,\n  ai_salary_currency: \"USD\",\n  url: \"https://jobs.anthropic.com/12345\",\n  description_text: \"We are looking for...\",\n  remote_derived: true,\n  locations_derived: [\"San Francisco\", \"New York\", \"Remote\"],\n  _context_workflow_run_id: 67890,\n  _context_company_id: \"anthropic\",\n  _context_company_name: \"Anthropic\",\n  _context_domain: \"anthropic.com\",\n  _context_resume_text: \"TED BEATIE - PRODUCT LEADER...\",\n  _context_profile_id: \"ted_beatie_pm\"\n}\n\nMERGED OUTPUT (combined object):\n{\n  // From Input 0 (AI evaluation)\n  job_id: \"12345\",\n  overall_score: 9,\n  recommendation: \"EXCELLENT_MATCH\",\n  strengths: [\"Senior level\", \"Infrastructure focus\", \"Remote\"],\n  weaknesses: [\"May require ML expertise\"],\n  key_mismatches: [],\n  seniority_match: 10,\n  domain_match: 9,\n  technical_depth: 8,\n  location_fit: 10,\n  compensation_fit: 9,\n  \n  // From Input 1 (Raw job)\n  id: \"12345\",\n  title: \"Senior Technical Product Manager\",\n  organization: \"Anthropic\",\n  ai_salary_minvalue: 200000,\n  ai_salary_maxvalue: 250000,\n  ai_salary_currency: \"USD\",\n  url: \"https://jobs.anthropic.com/12345\",\n  description_text: \"We are looking for...\",\n  remote_derived: true,\n  locations_derived: [\"San Francisco\", \"New York\", \"Remote\"],\n  _context_workflow_run_id: 67890,\n  _context_company_id: \"anthropic\",\n  _context_company_name: \"Anthropic\",\n  _context_domain: \"anthropic.com\",\n  _context_resume_text: \"TED BEATIE - PRODUCT LEADER...\",\n  _context_profile_id: \"ted_beatie_pm\"\n}\n\nCritical: Why job_id must match id\nIf job_id (Input 0) != id (Input 1):\n- Merge fails to find matching pair\n- Items don't combine\n- Downstream nodes receive incomplete data\n- Email formatting breaks\n- Job doesn't appear in email\n\nThis is why we explicitly include job_id in the AI prompt template.\nThe AI is instructed: \"You must include \\\"job_id\\\": \\\"{{ $json.id }}\\\"...\"\n\nParallel path timing:\nThe two inputs arrive at DIFFERENT speeds:\n- Input 0 (AI path): 2-5 seconds (slow - API call + processing)\n- Input 1 (Raw path): Instant (fast - no processing)\n\nThe Merge node WAITS for both inputs before proceeding.\nThis is automatic n8n behavior - merge nodes don't fire until\nthey have data on all input pins.\n\nBehavior during the wait:\n- Fast path (Input 1) arrives first and queues\n- Merge node holds and waits\n- Slow path (Input 0) arrives 2-5 seconds later\n- Merge node matches by job_id == id\n- Combined output fires to Format Job Card\n\nArchitectural benefit:\nThis parallel + merge pattern is preserved from v5 because it works well:\n- Raw data preserved immediately (backup in case AI fails)\n- AI evaluation runs independently (can fail without losing data)\n- Merge combines best of both (AI scores + complete job details)\n- Clean separation of concerns (AI intelligence vs. data preservation)\n- Visual representation in workflow (easy to understand)\n\nWhat happens next:\nThe merged data (AI evaluation + complete job fields) flows to:\n- Format Job Card: Creates HTML email card using:\n  • AI scores for badge colors and recommendations\n  • Job fields for company, title, salary, location display\n  • _context_workflow_run_id for email queue grouping\n  • Strengths/weaknesses/mismatches for detailed assessment\n\nAlternative approaches (and why we don't use them):\n\n1. Could pass job data through AI node:\n   - Pro: Single path, simpler\n   - Con: AI node doesn't preserve original fields\n   - Con: Would need to reconstruct everything from scratch\n   - Con: Risky if AI fails\n   \n2. Could store job data in workflow variable:\n   - Pro: Available anywhere in workflow\n   - Con: Complex state management\n   - Con: Error-prone across multiple job iterations\n   - Con: Variables don't persist across sub-workflow calls\n   \n3. Current approach (parallel + merge) - CHOSEN:\n   - Pro: Clean, explicit data flow\n   - Pro: No state management needed\n   - Pro: Visual in n8n workflow diagram\n   - Pro: Fault tolerant (AI can fail, raw data preserved)\n   - Pro: Easy to test paths independently\n   - Con: Requires merge matching logic (acceptable tradeoff)\n\nArchitectural improvement from v5 (v3.1):\nOLD: Input 1 came from \"Add Resume Context\" node\nNEW: Input 1 comes DIRECTLY from \"Loop Over Jobs\"\nBENEFIT: One less node in the workflow\n        Data flow is simpler and more direct\n        No intermediate transformation needed\n\nNext node: Format Job Card\n═══════════════════════════════════════════════════════════════════════════"
    },
    {
      "parameters": {
        "jsCode": "// Code from original Format Job Card node would go here\n// This is a placeholder - the actual implementation would be very long\n// See the original workflow file for the complete implementation"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1056,
        304
      ],
      "id": "47ff37ff-0cc1-4cbb-bced-16f1a91240a5",
      "name": "Format Job Card",
      "COMMENT": "═══════════════════════════════════════════════════════════════════════════\nNODE 6: FORMAT JOB CARD (COMPACT HTML GENERATOR)\n═══════════════════════════════════════════════════════════════════════════\nPurpose: Create compact, professional HTML card for each job\nInput: Single merged job (with AI evaluation + raw Apify data + context fields)\nOutput: Formatted HTML card + metadata for database/sorting\n\n[Full implementation would follow the original node's code]\n\nNote: This node contains extensive HTML generation logic.\nFor the complete documented implementation, see the original workflow file.\nThe node documentation would include:\n- Helper functions (formatSalary, formatLocation, getBadgeColor, etc.)\n- HTML card generation with responsive design\n- Color-coded badges based on recommendation\n- Detailed scoring display\n- AI assessment sections (strengths, weaknesses, mismatches)\n- Output structure for database insertion\n\nNext node: Save to Email Queue\n═══════════════════════════════════════════════════════════════════════════"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "FcYe2cOsjo5J6Pr5",
          "mode": "list",
          "cachedResultName": "email queue",
          "cachedResultUrl": "/projects/MIniGOtG65wFTuKC/datatables/FcYe2cOsjo5J6Pr5"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "workflow_run_id": "={{ $json.workflow_run_id }}",
            "recommendation": "={{ $json.recommendation }}",
            "overall_score": "={{ $json.overall_score }}",
            "html_card": "={{ $json.html_card }}",
            "job_id": "={{ $json.job_id }}",
            "company_name": "={{ $json.company_name }}",
            "job_title": "={{ $json.job_title }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "workflow_run_id",
              "displayName": "workflow_run_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "recommendation",
              "displayName": "recommendation",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "overall_score",
              "displayName": "overall_score",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "html_card",
              "displayName": "html_card",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "job_id",
              "displayName": "job_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "company_name",
              "displayName": "company_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "job_title",
              "displayName": "job_title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1280,
        304
      ],
      "id": "65a61eb8-0de6-43d3-8e4f-58efb2f182d1",
      "name": "Save to Email Queue",
      "COMMENT": "═══════════════════════════════════════════════════════════════════════════\nNODE 7: SAVE TO EMAIL QUEUE DATABASE\n═══════════════════════════════════════════════════════════════════════════\nInserts formatted job card into the 'email_queue' table for later aggregation.\n\n[Rest of the documentation would follow the pattern established in Loop Companies]\n\nNext node: Loop Over Jobs (loops back for next job in current company)\n═══════════════════════════════════════════════════════════════════════════"
    },
    {
      "parameters": {
        "jsCode": "// ============================================================================\n// NODE 8: WORKFLOW COMPLETE\n// Signals successful completion back to parent workflow\n// ============================================================================\n\n// Get all items that came through the loop (for counting)\nconst allItems = $input.all();\n\nreturn [{\n  json: {\n    status: 'success',\n    jobs_processed: allItems.length,\n    timestamp: new Date().toISOString()\n  }\n}];\n\n// Output: Simple success signal with job count\n// Parent workflow receives this and continues to next company"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "id": "00ee0542-485a-4737-8d68-673ea7c64bfb",
      "name": "Workflow Complete"
    }
  ],
  "pinData": {},
  "connections": {
    "Loop Over Jobs": {
      "main": [
        [
          {
            "node": "Workflow Complete",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Format Job Card",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Job Card": {
      "main": [
        [
          {
            "node": "Save to Email Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to Email Queue": {
      "main": [
        [
          {
            "node": "Loop Over Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start": {
      "main": [
        [
          {
            "node": "Loop Over Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "fb5dcc71-33c6-4946-ad44-9ff548171adc",
  "meta": {
    "instanceId": "7534cf3caceb89a410b24188fae76f3b891a0be6d8178ba8a99d892ed4a4777d"
  },
  "id": "TqY18KRTpfKplhh0",
  "tags": []
}
