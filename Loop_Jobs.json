{
  "name": "Loop_Jobs_v5-1",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -208,
        112
      ],
      "id": "2205a9d9-8401-40a0-be28-c4daafce09ee",
      "name": "Start",
      "notes": "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  NODE 1: WORKFLOW TRIGGER (SUB-WORKFLOW ENTRY POINT)  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  This is the entry point for the Job workflow,\n  which is called as a SUB-WORKFLOW from the\n  parent \"Loop Companies v2.1\" workflow.\n\n  How this workflow gets triggered:\n . Sub-workflow call: Parent workflow calls\n     this via Execute Workflow node\n     - Parent passes job data with _context_ fields\n     - This workflow processes jobs independently\n     - Returns control to parent when complete\n\n  What data arrives here (FROM PARENT WORKFLOW\n  v3.1):\n  When called from parent workflow, receives job\n  items with:\n\n  === APIFY JOB FIELDS ===\n  - id: Apify's unique job identifier\n  - title: Job title (\"Senior Technical Product Manager\")\n  - organization: Company name (\"Anthropic\")\n  - salary fields: ai_salary_minvalue,\n    ai_salary_maxvalue, ai_salary_currency\n  - location fields: locations_raw,\n    remote_derived, ai_work_arrangement\n  - description_text: Full job description\n  - url: Link to apply\n  - date_posted: When job was posted\n  - experience_level: Apify's AI-extracted\n    experience level\n  ... and many more Apify fields\n\n  === COMPANY CONTEXT FIELDS ===\n  - _context_workflow_run_id: Parent workflow's\n    execution ID\n  - _context_company_id: Company identifier\n    (\"anthropic\")\n  - _context_company_name: Company display name\n    (\"Anthropic\")\n  - _context_domain: Company domain\n    (\"anthropic.com\")\n\n  === PROFILE CONTEXT FIELDS ===\n  These are added by parent workflow's \"Add\n  Context\" node:\n  - _context_profile_id: Candidate profile\n    identifier (\"[id]\")\n  - _context_resume_text: Complete resume/\n    experience text for AI evaluation\n  - _context_target_criteria: Job search criteria JSON\n\n  1. NO HARDCODED DATA: Workflow is profile-agnostic\n  2. MULTI-USER READY: Different users can have\n     different profiles\n  3. TESTING FRIENDLY: Can test with different\n     profiles without editing workflow\n  4. SEPARATION OF CONCERNS: Parent handles\n     profile, this workflow handles evaluation\n  5. REUSABILITY: Same workflow can evaluate\n     jobs for any candidate\n  6. SIMPLER FLOW: One less node to maintain\n  7. VERSION CONTROL: Workflow JSON contains no\n     personal information\n  8. SECURITY: Profile can be stored encrypted\n     in database\n\n  Data flow visualization:\n  Start (receives jobs with _context_resume_text)\n  ‚Üí Loop Over Jobs (one job at a time) ‚Üí\n    PARALLEL SPLIT:\n      Path A: Message a model (AI uses\n              _context_resume_text) ‚Üí Parse ‚Üí Merge\n      Path B: Direct to Merge (preserves raw data) ‚Üí\n    MERGE ‚Üí Format Job Card ‚Üí Save to Email\n    Queue ‚Üí Loop back\n\n  Workflow purpose:\n  Process jobs ONE AT A TIME through:\n  1. Loop Over Jobs: Iterate through jobs (fault\n     tolerance)\n  2. Message a model: AI evaluation with Claude\n     Sonnet 4.5 using _context_resume_text\n  3. Parse AI Response: Extract and structure\n     evaluation\n  4. Merge: Combine AI evaluation with raw job\n     data (parallel paths)\n  5. Format Job Card: Generate HTML email card\n  6. Save to Email Queue: Store for email aggregation\n\n  Next node: Loop Over Jobs"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        16,
        112
      ],
      "id": "b727a283-eb27-4c2d-b8ab-32257c657239",
      "name": "Loop Over Jobs",
      "notes": "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  NODE 2: LOOP OVER JOBS (JOB PROCESSING\n  ORCHESTRATOR)  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  Processes jobs ONE AT A TIME using a loop pattern.\n\n  What is this loop doing?\n  - Takes array of jobs passed from parent\n    workflow (e.g., 8 jobs from Anthropic)\n  - Each job already includes _context_ fields\n    with profile data\n  - Processes each job individually through AI evaluation\n  - Batch size: 1 (default) means one job per\n    loop iteration\n\n  Why loop over jobs individually?\n  1. AI API RATE LIMITING: Avoid overwhelming\n     Claude API with parallel requests\n  2. COST TRACKING: Know exact number of AI\n     calls and costs\n  3. PROGRESS MONITORING: See real-time progress\n     through jobs\n  4. ERROR ISOLATION: If job #5 fails, jobs\n     #6-8 still process\n  5. SEQUENTIAL EVALUATION: Each job gets full\n     AI attention\n  6. BUDGET CONTROL: Can stop mid-run if needed\n\n  How the loop works:\n  ‚îå‚îÄ Loop iteration 1: Job 1 (\"Senior PM at\n  ‚îÇ  Anthropic\")\n  ‚îÇ  ‚îú‚îÄ Split to AI path + raw data path\n  ‚îÇ     (parallel)\n  ‚îÇ  ‚îú‚îÄ AI Evaluation ‚Üí Parse ‚Üí Merge\n  ‚îÇ  ‚îú‚îÄ Raw data ‚Üí Merge\n  ‚îÇ  ‚îú‚îÄ Format ‚Üí Save to email queue\n  ‚îÇ  ‚îî‚îÄ Return to loop node\n  ‚îÇ\n  ‚îú‚îÄ Loop iteration 2: Job 2 (\"Lead PM at\n  ‚îÇ  Anthropic\")\n  ‚îÇ  ‚îú‚îÄ Same parallel processing\n  ‚îÇ  ‚îî‚îÄ Return to loop node\n  ‚îÇ\n  ‚îî‚îÄ All jobs done ‚Üí Done branch activates\n\n  Two outputs (pins on the node):\n  1. DONE BRANCH (top pin):\n     - Fires ONCE after ALL jobs for current\n       company complete\n     - Routes to: Workflow Complete\n     - Signals to parent workflow: \"All jobs\n       processed, ready for next company\"\n\n  2. LOOP BRANCH (bottom pin):\n     - Fires ONCE PER JOB\n     - Routes to TWO nodes in parallel:\n       ‚Ä¢ Message a model (AI evaluation path)\n       ‚Ä¢ Merge (raw data preservation path)\n     - This parallel split is key to the architecture\n\n  Accessing current job in downstream nodes:\n  $('Loop Over Jobs').item.json\n  // This gives you the current job being processed\n  // Includes ALL fields from parent workflow:\n  // {\n  //   id: \"12345\",\n  //   title: \"Senior PM\",\n  //   description_text: \"...\",\n  //   _context_workflow_run_id: 67890,\n  //   _context_company_id: \"anthropic\",\n  //   _context_company_name: \"Anthropic\",\n  //   _context_resume_text: \"[resume]\",\n  //   _context_target_criteria: \"{...}\",\n  //   _context_profile_id: \"[id]\",\n  //   ... all other Apify fields\n  // }\n\n  Profile context availability (v3.1):\n  EVERY job in the loop has access to:\n  - _context_resume_text: Full resume for AI\n    evaluation (used in Message a model)\n  - _context_target_criteria: Search criteria\n    (for reference/future use)\n  - _context_profile_id: Profile identifier (for tracking)\n\n  Parallel processing pattern:\n  After Loop Over Jobs, the job data flows to\n  TWO destinations simultaneously:\n\n  Path A (AI Evaluation - Slow):\n  ‚îî‚îÄ Message a model (2-5 seconds, costs $0.003)\n     ‚îî‚îÄ Parse AI Response\n        ‚îî‚îÄ Merge (input 0)\n\n  Path B (Raw Data - Fast):\n  ‚îî‚îÄ Merge (input 1, instant, free)\n\n  Why both paths?\n  - Path A: Gets AI intelligence and scoring\n  - Path B: Preserves complete job data\n  - Merge: Combines AI evaluation with raw job fields\n  - Result: Job with BOTH AI scores AND all\n    original details\n\n  Timing example:\n  If Anthropic has 8 jobs:\n  - Loop executes 8 times (once per job)\n  - Each iteration: 2-5 seconds for A evaluation\n  - Total: 16-40 seconds for all 8 jobs\n  - Then Done branch fires once\n  - Parent workflow continues to next company\n\n  Loop-back path:\n  Save to Email Queue ‚Üí Loop Over Jobs ‚Üí\n  (next job iteration)\n\n  When all jobs complete:\n  Loop Over Jobs (Done) ‚Üí Workflow Complete ‚Üí\n  Return to parent\n\n  Next nodes (PARALLEL):\n  - Loop branch (AI path) ‚Üí Message a model\n  - Loop branch (Raw path) ‚Üí Merge (input 1)"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "claude-sonnet-4-5-20250929"
        },
        "messages": {
          "values": [
            {
              "content": "=Candidate Profile:\n{{ $json._context_resume_text }}\n\nJob Details:\n- Job ID: {{ $json.id }}\n- Title: {{ $json.title }}\n- Company: {{ $json.organization }}\n- Location: {{ $json.locations_derived || $json.location_locality }}, {{ $json.regions_derived || $json.location_region }} (Remote: {{ $json.remote_derived }})\n- Work Arrangement: {{ $json.ai_work_arrangement }}\n- Salary: {{ $json.ai_salary_minvalue }} - {{ $json.ai_salary_maxvalue }} {{ $json.ai_salary_currency }}\n- Experience Level: {{ $json.ai_experience_level }}\n- URL: {{ $json.url }}\n\nJob Description:\n{{ $json.description_text }}\n\nEvaluate this job against the candidate's profile and return ONLY valid JSON with this exact structure:\n\n{\n  \"job_id\": \"{{ $json.id }}\",\n  \"overall_score\": <number 1-10>,\n  \"recommendation\": \"<EXCELLENT_MATCH|GOOD_MATCH|CONSIDER|POOR_FIT|REJECT>\",\n  \"detailed_scores\": {\n    \"seniority_match\": <number 1-10>,\n    \"domain_match\": <number 1-10>,\n    \"technical_depth\": <number 1-10>,\n    \"location_fit\": <number 1-10>,\n    \"compensation\": <number 1-10>\n  },\n  \"reasoning\": {\n    \"strengths\": [<array of 3-6 specific strengths>],\n    \"weaknesses\": [<array of key concerns or gaps>],\n    \"key_mismatches\": [<array of critical misalignments if any>]\n  },\n  \"match_explanation\": \"<2-4 sentence summary explaining the overall assessment>\"\n}\n\nCRITICAL: You must include \"job_id\": \"{{ $json.id }}\" as the first field in your JSON response.\n\nScoring criteria:\n\n{{ $json._scoring_criteria }}\n\nReturn only the JSON, no markdown formatting."
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.anthropic",
      "typeVersion": 1,
      "position": [
        464,
        128
      ],
      "id": "cced917a-eccd-4a0d-831f-32d6bf3d55ba",
      "name": "Message a model",
      "credentials": {
        "anthropicApi": {
          "name": "Anthropic account"
        }
      },
      "notes": "=‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  NODE 3: AI JOB EVALUATION (CLAUDE SONNET 4.5)  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  Sends job + candidate profile to Claude AI for\n  intelligent evaluation.\n\n  What this node does:\n  Calls Anthropic's Claude API with:\n  1. Complete candidate profile via\n     _context_resume_text (from parent workflow)\n  2. Full job details (title, company, salary,\n     location, description)\n  3. Structured evaluation prompt with scoring\n     dimensions\n\n  AI Model: claude-sonnet-4-5-20250929\n  - Anthropic's Claude Sonnet 4.5 model\n  - Fast, high-quality reasoning\n  - Excellent at structured output (JSON)\n  - Strong at comparative analysis\n  - Optimized for tool use and long-context\n    understanding\n\n  Prompt structure breakdown:\n\n  === SECTION 1: CANDIDATE PROFILE ===\n  {{ $json._context_resume_text }}\n\n  The _context_resume_text field contains the\n  complete candidate profile:\n  - Professional summary\n  - Key achievements\n  - Technical expertise\n  - Recent experience (detailed)\n  - Target role criteria\n  - Ideal fit indicators\n\n  === SECTION 2: JOB DETAILS ===\n  All relevant job fields extracted from Apify data:\n  - {{ $json.id }}: Unique job identifier\n    (critical for merge)\n  - {{ $json.title }}: Job title\n  - {{ $json.organization }}: Company name\n  - {{ $json.locations_derived }}: Location information\n  - {{ $json.ai_salary_minvalue }}: Salary range\n  - {{ $json.description_text }}: Full job description\n\n  === SECTION 3: EVALUATION STRUCTURE ===\n  Prompt instructs AI to return JSON with:\n\n  1. OVERALL ASSESSMENT:\n     - overall_score: 1-10 rating\n     - recommendation: EXCELLENT_MATCH |\n       GOOD_MATCH | CONSIDER | POOR_FIT | REJECT\n     - match_explanation: 2-4 sentence summary\n\n  2. DETAILED SCORES (5 dimensions, each 1-10):\n     - seniority_match: Is this Senior/Lead/\n       Principal/Director level?\n     - domain_match: Infrastructure/Platform/\n       DevEx/API/Cloud focus?\n     - technical_depth: Backend systems/\n       integrations/developer tools?\n     - location_fit: Remote, Hybrid NYC Metro, or\n       Hybrid Bay Area?\n     - compensation: Meets $190k+ threshold?\n\n  3. REASONING:\n     - strengths: 3-6 specific reasons this job\n       is a good fit\n     - weaknesses: Key concerns or gaps\n     - key_mismatches: Critical dealbreakers (if any)\n\n  Why include job_id in AI response?\n  CRITICAL: The job_id field is explicitly\n  requested in the prompt template. This ensures\n  the AI's response can be matched back to the\n  original job in the Merge node. The Merge node uses:\n  - AI response: job_id field\n  - Raw job data: id field\n  These must match for proper merging.\n\n  Timing:\n  - API latency: 2-5 seconds per job (depends on\n    job description length)\n  - Parallel processing: NO (sequential loop\n    prevents API throttling)\n  - For 8 Anthropic jobs: 16-40 seconds total\n\n  Error handling:\n  - If AI fails: Error passed to downstream nodes\n  - n8n catches errors in execution log\n  - Could implement retry logic for transient failures\n  - Parse node validates JSON structure downstream\n\n  Why this is the \"slow path\":\n  Compared to the parallel \"raw data\" path that\n  goes directly to Merge:\n  - AI path (this node): 2-5 seconds per job, costs $0.003\n  - Raw path (parallel): Instant, free\n\n  Both paths are necessary:\n  - AI path provides intelligence and evaluation\n    (this node ‚Üí Parse ‚Üí Merge input 0)\n  - Raw path preserves complete job data (direct\n    to Merge input 1)\n  - Merge combines both for complete\n    job+evaluation object\n\n  Production considerations:\n  1. RATE LIMITING: Sequential processing avoids\n     API throttling\n  2. COST MONITORING: Track usage via Anthropic\n     dashboard\n  3. QUALITY CHECKS: Validate AI responses are\n     well-structured\n  4. A/B TESTING: Could test different prompts\n     or scoring criteria\n  5. CACHING: Could cache evaluations for\n     identical jobs (future enhancement)\n  6. PROMPT TUNING: Adjust scoring criteria\n     based on false positives/negatives\n\n  Next node: Parse AI Response"
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// NODE 5: PARSE AI RESPONSE\n// ====================================================================\n\n// STEP 1: Extract raw response text from Claude's response structure\nlet response = $json.content[0].text;\n// Example: \"```json\\n{...}\\n```\" or \"{...}\"\n\n// STEP 2: Clean up markdown code fences if present\n// Claude sometimes wraps JSON in markdown code blocks\n// Remove: ```json at start and ``` at end\nresponse = response.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n// Now we have clean JSON string: \"{...}\"\n\n// STEP 3: Parse JSON string into JavaScript object\nconst evaluation = JSON.parse(response);\n// If parsing fails, this will throw an error (caught by n8n error handling)\n\n// STEP 4: Restructure into standardized format\nreturn [{\n  json: {\n    // === CRITICAL: Extract job_id for merge matching ===\n    // This MUST match the job ID from the raw job data\n    // The Merge node uses this to link AI evaluation to correct job\n    job_id: evaluation.job_id,\n    \n    // === Full evaluation object for reference ===\n    // Store complete AI response in case we need it later\n    // ai_evaluation: evaluation,\n    \n    // === Top-level fields for easy access ===\n    // Extract commonly-used fields to top level\n    overall_score: evaluation.overall_score,\n    recommendation: evaluation.recommendation,\n    \n    // === Reasoning details ===\n    // Extract arrays from nested reasoning object\n    // Use || [] to provide empty array fallback if field missing\n    strengths: evaluation.reasoning?.strengths || [],\n    weaknesses: evaluation.reasoning?.weaknesses || [],\n    key_mismatches: evaluation.reasoning?.key_mismatches || [],\n    match_explanation: evaluation.match_explanation || '',\n    \n    // === Individual scoring dimensions ===\n    // Extract each score from nested detailed_scores object\n    // Use || 0 to provide default score if field missing\n    seniority_match: evaluation.detailed_scores?.seniority_match || 0,\n    domain_match: evaluation.detailed_scores?.domain_match || 0,\n    technical_depth: evaluation.detailed_scores?.technical_depth || 0,\n    location_fit: evaluation.detailed_scores?.location_fit || 0,\n    compensation_fit: evaluation.detailed_scores?.compensation || 0\n  }\n}];\n\n// WHAT GETS OUTPUT:\n// Flattened, structured evaluation data\n// Example:\n// {\n//   job_id: \"12345\",\n//   ai_evaluation: { <full nested object> },\n//   overall_score: 9,\n//   recommendation: \"EXCELLENT_MATCH\",\n//   strengths: [\"Senior level\", \"Infrastructure focus\", ...],\n//   weaknesses: [\"May require ML expertise\"],\n//   key_mismatches: [],\n//   match_explanation: \"This is an excellent match...\",\n//   seniority_match: 10,\n//   domain_match: 9,\n//   technical_depth: 8,\n//   location_fit: 10,\n//   compensation_fit: 9\n// }\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        128
      ],
      "id": "6a633eeb-e7c7-4d8a-84a4-8323dc77b2b8",
      "name": "Parse AI Response",
      "notes": "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  NODE 4: PARSE AI RESPONSE\n  Extracts and structures AI evaluation from\n  Claude's JSON response  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  THE PROBLEM:\n  Claude returns its evaluation in a specific format:\n  $json.content[0].text contains the actual JSON string\n  We need to:\n  1. Extract the JSON string\n  2. Clean up any markdown formatting\n  3. Parse into JavaScript object\n  4. Restructure for database and merge compatibility\n\n  STEP 1: Extract raw response text from Claude's response structure\n  let response = $json.content[0].text;\n  // Example: \"```json\\n{...}\\n```\" or \"{...}\"\n\n  STEP 2: Clean up markdown code fences if present\n  // Claude sometimes wraps JSON in markdown code blocks\n  // Remove: ```json at start and ``` at end response = response.replace(/```json\\n?/g,\n    '').replace(/```\\n?/g, '').trim();\n  // Now we have clean JSON string: \"{...}\"\n\n  STEP 3: Parse JSON string into JavaScript object\n  const evaluation = JSON.parse(response);\n  // If parsing fails, this will throw an error\n  // (caught by n8n error handling)\n\n  STEP 4: Restructure into standardized format\n  return [{\n    json: {\n      // === CRITICAL: Extract job_id for merge\n      // matching ===\n      // This MUST match the job ID from the raw job data\n      // The Merge node uses this to link AI\n      // evaluation to correct job\n      job_id: evaluation.job_id,\n\n      // === Full evaluation object for reference ===\n      // Store complete AI response in case we need it later\n      // Useful for debugging or future analysis\n      ai_evaluation: evaluation,\n\n      // === Top-level fields for easy access ===\n      // Extract commonly-used fields to top level\n      // Makes downstream formatting easier\n      overall_score: evaluation.overall_score,\n      recommendation: evaluation.recommendation,\n\n      // === Reasoning details ===\n      // Extract arrays from nested reasoning object\n      // Use || [] to provide empty array\n      // fallback if field missing\n      // This prevents errors in downstream formatting\n      strengths: evaluation.reasoning?.strengths || [],\n      weaknesses: evaluation.reasoning?.weaknesses || [],\n      key_mismatches:\n        evaluation.reasoning?.key_mismatches || [],\n      match_explanation:\n        evaluation.match_explanation || '',\n\n      // === Individual scoring dimensions ===\n      // Extract each score from nested detailed_scores object\n      // Use || 0 to provide default score if field missing\n      seniority_match:\n        evaluation.detailed_scores?.seniority_match || 0,\n      domain_match:\n        evaluation.detailed_scores?.domain_match || 0,\n      technical_depth:\n        evaluation.detailed_scores?.technical_depth || 0,\n      location_fit:\n        evaluation.detailed_scores?.location_fit || 0,\n      compensation_fit:\n        evaluation.detailed_scores?.compensation || 0\n    }\n  }];\n\n  WHAT GETS OUTPUT:\n  Flattened, structured evaluation data\n\n  WHY FLATTEN THE STRUCTURE?\n  1. EASIER MERGE: Top-level fields merge cleanly with job data\n  2. DATABASE FRIENDLY: Can map directly to table columns\n  3. EMAIL FORMATTING: Easy access to scores and arrays\n  4. BACKUP: Keep full ai_evaluation object for reference\n  5. QUERY FRIENDLY: Can query by score without parsing JSON\n\n  WHY job_id IS CRITICAL:\n  The Merge node (next step) needs to match this\n  AI evaluation with the corresponding raw job data. It does this by comparing:\n  - AI evaluation (this output): job_id field\n  - Raw job data (parallel path): id field\n\n  Match logic: WHERE job_id == id\n\n  If job_id is missing or incorrect:\n  - Merge will fail to find matching pair\n  - AI evaluation gets orphaned\n  - Job card generation breaks\n  - Email doesn't include this job\n\n  ERROR HANDLING:\n  If JSON.parse() fails:\n  - n8n catches error and shows in execution log\n  - Can add try/catch for graceful error handling\n  - Could implement retry logic with different prompt\n  - Could log malformed responses for debugging\n  - Could alert on repeated failures\n\n  VALIDATION CHECKS (could be added for production):\n  - Verify job_id exists and matches expected format\n  - Confirm overall_score is 1-10\n  - Validate recommendation is one of allowed values\n  - Check that required fields are present\n  - Ensure arrays are actually arrays\n  - Validate score ranges (1-10)\n\n  Merge node receives BOTH:\n  - Input 0: AI evaluation (this node's output)\n  - Input 1: Complete job data with _context_\n    fields (from Loop Over Jobs)\n\n  Result: Job with BOTH AI evaluation AND all original job fields\n\n  PRODUCTION MONITORING:\n  Track these metrics:\n  - Parse success rate\n  - Average overall_score (helps calibrate scoring)\n  - Most common recommendations\n  - Frequency of key_mismatches\n  - AI response time trends\n  - Cost per evaluation\n\n  Next node: Merge (input 0)"
    },
    {
      "parameters": {
        "mode": "combine",
        "advanced": true,
        "mergeByFields": {
          "values": [
            {
              "field1": "job_id",
              "field2": "id"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        464,
        368
      ],
      "id": "d9a20acf-7d0e-4515-9092-0a00146bf802",
      "name": "Merge",
      "notes": "=‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  NODE 5: MERGE AI EVALUATION WITH RAW JOB DATA  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  Combines AI evaluation results with complete\n  job data from Apify.\n\n  What is this node doing?\n  The Merge node receives data from TWO parallel\n  paths and combines them:\n\n  INPUT 0 (Top pin - AI evaluation path):\n  Comes from: Parse AI Response\n  Contains:\n  - job_id: \"12345\" (for matching)\n  - overall_score: 9\n  - recommendation: \"EXCELLENT_MATCH\"\n  - detailed scores: seniority_match,\n    domain_match, etc.\n  - reasoning arrays: strengths, weaknesses,\n    key_mismatches\n  - match_explanation: AI's summary text\n  - ai_evaluation: Full nested evaluation object\n\n  INPUT 1 (Bottom pin - Raw job data path):\n  Comes from: Loop Over Jobs (DIRECT connection\n  in v3.1)\n  Contains:\n  - id: \"12345\" (matches job_id from Input 0)\n  - All Apify fields: title, organization,\n    salary, location, description_text\n  - All _context_ fields: workflow_run_id,\n    company_id, company_name, domain\n  - Profile context fields: _context_resume_text,\n    _context_profile_id, _context_target_criteria\n\n  Merge Mode: Combine by Fields\n  - Matches items based on specified field pairs\n  - Field 1 (from Input 0): job_id\n  - Field 2 (from Input 1): id\n  - When job_id == id, combine those items into\n    single object\n\n  Why we need both inputs:\n  1. AI EVALUATION (Input 0):\n     - Provides intelligence and scoring\n     - Claude only returns what we asked for\n       (evaluation JSON)\n\n  2. RAW JOB DATA (Input 1):\n     - Preserves ALL original Apify fields\n     - Includes _context_ fields for tracking and grouping\n     - Includes _context_resume_text (though not\n       used after AI evaluation)\n\n  3. MERGED OUTPUT:\n     - Best of both worlds\n     - AI scores + Complete job details + Context fields\n     - Everything needed for email formatting\n     - Single comprehensive object per job\n\n  Critical: Why job_id must match id\n  If job_id (Input 0) != id (Input 1):\n  - Merge fails to find matching pair\n  - Items don't combine\n  - Downstream nodes receive incomplete data\n  - Email formatting breaks\n  - Job doesn't appear in email\n\n  This is why we explicitly include job_id in\n  the AI prompt template. The AI is instructed:\n  \"You must include \\\"job_id\\\": \\\"{{ $json.id\n  }}\\\"...\"\n\n  Parallel path timing:\n  The two inputs arrive at DIFFERENT speeds:\n  - Input 0 (AI path): 2-5 seconds (slow - API\n    call + processing)\n  - Input 1 (Raw path): Instant (fast - no\n    processing)\n\n  The Merge node WAITS for both inputs before\n  proceeding. This is automatic n8n behavior -\n  merge nodes don't fire until they have data on\n  all input pins.\n\n  Behavior during the wait:\n  - Fast path (Input 1) arrives first and queues\n  - Merge node holds and waits\n  - Slow path (Input 0) arrives 2-5 seconds later\n  - Merge node matches by job_id == id\n  - Combined output fires to Format Job Card\n\n  Architectural benefit:\n  This parallel + merge pattern is preserved\n  from v5 because it works well:\n  - Raw data preserved immediately (backup in\n    case AI fails)\n  - AI evaluation runs independently (can fail\n    without losing data)\n  - Merge combines best of both (AI scores +\n    complete job details)\n  - Clean separation of concerns (AI\n    intelligence vs. data preservation)\n  - Visual representation in workflow (easy to\n    understand)\n\n  What happens next:\n  The merged data (AI evaluation + complete job\n  fields) flows to:\n  - Format Job Card: Creates HTML email card\n    using:\n    ‚Ä¢ AI scores for badge colors and recommendations\n    ‚Ä¢ Job fields for company, title, salary, location display\n    ‚Ä¢ _context_workflow_run_id for email queue\n      grouping\n    ‚Ä¢ Strengths/weaknesses/mismatches for\n      detailed assessment\n"
    },
    {
      "parameters": {
        "jsCode": "// =====================================================================\n// NODE: WORKFLOW COMPLETE\n// =====================================================================\n\n  // Get count from earlier in the workflow, not from input\n  const processedJobs = $('Insert email row').all();\n\n  return [{\n    json: {\n      status: 'success',\n      jobs_processed: processedJobs.length,\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n// Output: Simple success signal with job count\n// Parent workflow receives this and continues to next company"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        -80
      ],
      "id": "d0b7a436-e4f4-4b71-b980-c13eb13bd55b",
      "name": "Workflow Complete",
      "notes": "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  NODE 8: WORKFLOW COMPLETE\n  Signals successful completion back to parent workflow  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  Get all items that came through the loop (for counting)\n  const allItems = $input.all();\n\n  return [{\n    json: {\n      status: 'success',\n      jobs_processed: allItems.length,\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n  Output: Simple success signal with job count\n  Parent workflow receives this and continues to next company\n"
    },
    {
      "parameters": {
        "jsCode": "// ====================================================================\n// NODE 7: FORMAT JOB CARD (COMPACT HTML GENERATOR)\n// ====================================================================\n\n// This node receives the COMPLETE job data from Merge node:\n// - All AI evaluation fields (scores, recommendation, reasoning)\n// - All raw Apify fields (title, company, salary, location, description)\n// - All context fields (workflow_run_id, company_id, etc.)\n\nconst job = $json;\n\n// ====================================================================\n// HELPER FUNCTIONS\n// ====================================================================\n\n// FORMAT SALARY DISPLAY\n// Handles missing data, different currencies, and ranges\nconst formatSalary = () => {\n  const min = job.ai_salary_minvalue || job.salary_min;\n  const max = job.ai_salary_maxvalue || job.salary_max;\n  const currency = job.ai_salary_currency || job.salary_currency || 'USD';\n  \n  if (!min && !max) return 'Not specified';\n  \n  const formatNum = (num) => {\n    if (!num) return '';\n    const formatted = parseInt(num).toLocaleString();\n    return currency === 'USD' ? `$${formatted}` : `${formatted} ${currency}`;\n  };\n  \n  if (min && max) return `${formatNum(min)} - ${formatNum(max)}`;\n  return formatNum(min || max);\n};\n\n// FORMAT LOCATION DISPLAY\n// Prioritizes most reliable location data sources\nconst formatLocation = () => {\n  const parts = [];\n  \n  // PRIORITY 1: Try ai_remote_location array (most reliable for remote/hybrid)\n  if (job.ai_remote_location && Array.isArray(job.ai_remote_location) && job.ai_remote_location.length > 0) {\n    // Take first location, or show count if multiple\n    if (job.ai_remote_location.length === 1) {\n      parts.push(job.ai_remote_location[0]);\n    } else {\n      parts.push(`${job.ai_remote_location[0]} (+${job.ai_remote_location.length - 1} more)`);\n    }\n  } \n  // PRIORITY 2: Try locations_raw structure\n  else if (job.locations_raw?.[0]?.address?.addressLocality) {\n    const loc = job.locations_raw[0].address.addressLocality;\n    // If it's a concatenated string with |, take first location\n    parts.push(loc.includes('|') ? loc.split('|')[0].trim() : loc);\n  }\n  // PRIORITY 3: Try locations_derived or cities_derived\n  else if (job.locations_derived?.[0]) {\n    parts.push(job.locations_derived[0]);\n  } else if (job.cities_derived?.[0]) {\n    const city = job.cities_derived[0];\n    const region = job.regions_derived?.[0];\n    parts.push(region && region !== city ? `${city}, ${region}` : city);\n  }\n  \n  // Add work arrangement with emoji\n  if (job.remote_derived === true || job.remote_derived === 'true') {\n    parts.push('üè† Remote');\n  } else if (job.ai_work_arrangement) {\n    parts.push(`üìç ${job.ai_work_arrangement}`);\n  }\n  \n  return parts.length ? parts.join(' ‚Ä¢ ') : 'Location not specified';\n};\n\n// GET BADGE COLOR BY RECOMMENDATION\n// Maps recommendation to color-coded badge\nconst getBadgeColor = (rec) => {\n  const colors = {\n    'EXCELLENT_MATCH': '#10b981',  // Green\n    'GOOD_MATCH': '#3b82f6',       // Blue\n    'CONSIDER': '#f59e0b',         // Amber\n    'POOR_FIT': '#ef4444',         // Red\n    'REJECT': '#991b1b',           // Dark red\n    'UNKNOWN': '#6b7280'           // Gray\n  };\n  return colors[rec] || '#6b7280';\n};\n\n// FORMAT ARRAY AS LIST ITEMS\n// Safely converts arrays to HTML list items\nconst formatList = (arr) => {\n  if (!arr || !Array.isArray(arr) || arr.length === 0) return '';\n  return arr.map(item => `<li style=\"margin-bottom: 3px;\">${item}</li>`).join('');\n};\n\n// SAFELY GET RECOMMENDATION AND SCORE\n// Multiple fallback paths to ensure we always have values\nconst recommendation = job.recommendation || job.ai_evaluation?.recommendation || 'UNKNOWN';\nconst overallScore = job.overall_score || job.ai_evaluation?.overall_score || 0;\n\n// ====================================================================\n// BUILD COMPACT HTML CARD\n// ====================================================================\n\nconst htmlCard = `\n<div style=\"margin-bottom: 0; padding: 16px; border: 1px solid #e5e7eb; border-radius: 8px; background: #ffffff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\">\n  \n  <!-- Header: Title, Company, Badge -->\n  <div style=\"display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px; flex-wrap: wrap; gap: 10px;\">\n    <div style=\"flex: 1; min-width: 250px;\">\n      <h2 style=\"margin: 0 0 4px 0; color: #111827; font-size: 18px; font-weight: 600; line-height: 1.3;\">\n        ${job.title || job.job_title || 'Position Title Not Available'}\n      </h2>\n      <p style=\"margin: 0; color: #6b7280; font-size: 14px;\">\n        ${job.organization || job.company_name || 'Company Not Specified'}\n      </p>\n    </div>\n    <div style=\"background: ${getBadgeColor(recommendation)}; color: white; padding: 6px 12px; border-radius: 6px; font-size: 13px; font-weight: 600; white-space: nowrap; text-align: center;\">\n      <div style=\"font-size: 16px; margin-bottom: 2px;\">${overallScore}/10</div>\n      <div style=\"font-size: 10px; opacity: 0.9;\">${recommendation.replace(/_/g, ' ')}</div>\n    </div>\n  </div>\n\n  <!-- Compact Details + Scores Grid -->\n  <div style=\"margin-bottom: 12px; padding: 12px; background: #f9fafb; border-radius: 6px; border-left: 3px solid ${getBadgeColor(recommendation)};\">\n    \n    <!-- Two Column Layout for Details -->\n    <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px; margin-bottom: 10px; font-size: 13px;\">\n      <div>\n        <strong style=\"color: #374151;\">üí∞ Comp:</strong> \n        <span style=\"color: #111827;\">${formatSalary()}</span>\n      </div>\n      <div>\n        <strong style=\"color: #374151;\">üìä Level:</strong> \n        <span style=\"color: #111827;\">${job.ai_experience_level || job.experience_level || 'Not specified'}</span>\n      </div>\n      <div>\n        <strong style=\"color: #374151;\">üìç Location:</strong> \n        <span style=\"color: #111827;\">${formatLocation()}</span>\n      </div>\n      <div>\n        <strong style=\"color: #374151;\">üìÖ Posted:</strong> \n        <span style=\"color: #111827;\">${job.date_posted ? new Date(job.date_posted).toLocaleDateString() : 'Recently'}</span>\n      </div>\n    </div>\n\n    <!-- Apply Link -->\n    <div style=\"font-size: 13px; padding-top: 8px; border-top: 1px solid #e5e7eb;\">\n      <strong style=\"color: #374151;\">üîó Apply:</strong> \n      <a href=\"${job.url || job.job_url || '#'}\" style=\"color: #3b82f6; text-decoration: none;\" target=\"_blank\">View Job Posting ‚Üí</a>\n    </div>\n\n    <!-- Inline Scores (Compact) -->\n    <div style=\"margin-top: 10px; padding-top: 10px; border-top: 1px solid #e5e7eb;\">\n      <div style=\"display: flex; justify-content: space-between; align-items: center; font-size: 11px;\">\n        <span style=\"color: #6b7280; font-weight: 600;\">SCORES:</span>\n        <div style=\"display: flex; gap: 10px;\">\n          <span style=\"color: #374151;\"><strong>Senior:</strong> ${job.seniority_match || 0}</span>\n          <span style=\"color: #374151;\"><strong>Domain:</strong> ${job.domain_match || 0}</span>\n          <span style=\"color: #374151;\"><strong>Tech:</strong> ${job.technical_depth || 0}</span>\n          <span style=\"color: #374151;\"><strong>Loc:</strong> ${job.location_fit || 0}</span>\n          <span style=\"color: #374151;\"><strong>Comp:</strong> ${job.compensation_fit || 0}</span>\n        </div>\n      </div>\n    </div>\n\n  </div>\n\n  <!-- AI Match Explanation -->\n  ${job.match_explanation ? `\n  <div style=\"margin-bottom: 10px;\">\n    <strong style=\"color: #374151; display: block; margin-bottom: 6px; font-size: 13px;\">‚ú® AI Assessment:</strong>\n    <p style=\"margin: 0; color: #4b5563; font-size: 12px; line-height: 1.5; padding: 8px; background: #fefce8; border-radius: 4px; border-left: 3px solid #fbbf24;\">\n      ${job.match_explanation}\n    </p>\n  </div>\n  ` : ''}\n\n  <!-- Strengths -->\n  ${job.strengths && Array.isArray(job.strengths) && job.strengths.length > 0 ? `\n  <div style=\"margin-bottom: 10px;\">\n    <strong style=\"color: #10b981; display: block; margin-bottom: 4px; font-size: 13px;\">‚úÖ Strengths:</strong>\n    <ul style=\"margin: 0; padding-left: 20px; color: #4b5563; font-size: 12px; line-height: 1.4;\">\n      ${formatList(job.strengths)}\n    </ul>\n  </div>\n  ` : ''}\n\n  <!-- Weaknesses/Concerns -->\n  ${job.weaknesses && Array.isArray(job.weaknesses) && job.weaknesses.length > 0 ? `\n  <div style=\"margin-bottom: 10px;\">\n    <strong style=\"color: #f59e0b; display: block; margin-bottom: 4px; font-size: 13px;\">‚ö†Ô∏è Considerations:</strong>\n    <ul style=\"margin: 0; padding-left: 20px; color: #4b5563; font-size: 12px; line-height: 1.4;\">\n      ${formatList(job.weaknesses)}\n    </ul>\n  </div>\n  ` : ''}\n\n  <!-- Key Mismatches -->\n  ${job.key_mismatches && Array.isArray(job.key_mismatches) && job.key_mismatches.length > 0 ? `\n  <div>\n    <strong style=\"color: #ef4444; display: block; margin-bottom: 4px; font-size: 13px;\">üö´ Mismatches:</strong>\n    <ul style=\"margin: 0; padding-left: 20px; color: #4b5563; font-size: 12px; line-height: 1.4;\">\n      ${formatList(job.key_mismatches)}\n    </ul>\n  </div>\n  ` : ''}\n\n</div>\n`;\n\n// ====================================================================\n// OUTPUT STRUCTURE\n// ====================================================================\n\nreturn [{\n  json: {\n    // === CORE IDENTIFIERS ===\n    // Multiple fallback paths to ensure we always have IDs\n    job_id: job.job_id || job.id,\n    company_id: job.company_id || job._context_company_id || 'unknown',\n    company_name: job.organization || job.company_name,\n    \n    // === SORTING FIELDS ===\n    // Email workflow will sort by overall_score DESC\n    recommendation: recommendation,\n    overall_score: overallScore,\n    \n    // === HTML CARD FOR EMAIL ===\n    // Complete, self-contained HTML card\n    // Can be directly inserted into email body\n    html_card: htmlCard,\n    \n    // === KEY DETAILS FOR DATABASE REFERENCE ===\n    // Minimal searchable fields (HTML card has complete details)\n    job_title: job.title || job.job_title,\n    job_url: job.url || job.job_url,\n    salary_min: job.ai_salary_minvalue || job.salary_min,\n    salary_max: job.ai_salary_maxvalue || job.salary_max,\n    location: formatLocation(),\n    date_posted: job.date_posted,\n\n    // === WORKFLOW TRACKING ===\n    // CRITICAL: workflow_run_id links all jobs from this workflow run\n    // Email workflow will query: \"SELECT * WHERE workflow_run_id = X\"\n    workflow_run_id: job._context_workflow_run_id || $execution.id,\n    \n    // === TIMESTAMP ===\n    processed_at: new Date().toISOString()\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        368
      ],
      "id": "4d8984f9-823c-4635-944c-e2c0ecf9fdff",
      "name": "Format Job Card",
      "notes": "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  NODE 6: FORMAT JOB CARD (COMPACT HTML GENERATOR)  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  Purpose: Create compact, professional HTML card for each job\n  Input: Single merged job (with AI evaluation +  raw Apify data + context fields)\n  Output: Formatted HTML card + metadata for database/sorting\n\n  The node output includes:\n  - Helper functions (formatSalary, formatLocation, getBadgeColor, etc.)\n  - HTML card generation with responsive design\n  - Color-coded badges based on recommendation\n  - Detailed scoring display\n  - AI assessment sections (strengths, weaknesses, mismatches)\n  - Output structure for database insertion\n\n  Next node: Save to Email Queue"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "mode": "list",
          "cachedResultName": "Email_Queue"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "workflow_run_id": "={{ $json.workflow_run_id }}",
            "recommendation": "={{ $json.recommendation }}",
            "overall_score": "={{ $json.overall_score }}",
            "html_card": "={{ $json.html_card }}",
            "job_id": "={{ $json.job_id }}",
            "company_name": "={{ $json.company_name }}",
            "job_title": "={{ $json.job_title }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "workflow_run_id",
              "displayName": "workflow_run_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "recommendation",
              "displayName": "recommendation",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "overall_score",
              "displayName": "overall_score",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "html_card",
              "displayName": "html_card",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "job_id",
              "displayName": "job_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "company_name",
              "displayName": "company_name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "job_title",
              "displayName": "job_title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        880,
        368
      ],
      "id": "21fdae62-a880-4573-8e96-2c196a67c828",
      "name": "Insert email row",
      "notes": "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  NODE 7: SAVE TO EMAIL QUEUE DATABASE  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  Inserts formatted job card into the\n  'email_queue' table for later aggregation.\n\n  Next node: Loop Over Jobs (loops back for next\n  job in current company)\n"
    },
    {
      "parameters": {
        "jsCode": "// =====================================================================\n// NODE: BUILD AI PROMPT (Dynamic Scoring Criteria)\n// =====================================================================\n// This node sits between \"Loop Over Jobs\" and \"Message a model\"\n//\n// Purpose: Parse target_criteria JSON and extract scoring criteria\n// for dynamic prompt construction\n//\n// Input: Job data with _context_target_criteria JSON string\n// Output: Job data with _scoring_criteria and _detailed_scores_structure fields\n// =====================================================================\n\nconst job = $json;\n\n// =====================================================================\n// PARSE TARGET CRITERIA\n// =====================================================================\n\nlet criteria;\ntry {\n  criteria = JSON.parse(job._context_target_criteria);\n} catch (e) {\n  throw new Error(`Failed to parse target_criteria JSON: ${e.message}`);\n}\n\nconst scoringConfig = criteria.ai_scoring_criteria;\n\nif (!scoringConfig || !scoringConfig.dimensions) {\n  throw new Error('ai_scoring_criteria or dimensions missing from target_criteria');\n}\n\n// =====================================================================\n// BUILD SCORING CRITERIA TEXT\n// =====================================================================\n// Converts dimensions array to bullet-point text for AI prompt\n// Example output:\n// - Seniority Match: Senior/Lead/Principal/Director level roles\n// - Domain Match: Infrastructure, Platform Engineering, Developer Experience\n// - Technical Depth: Backend systems, integrations, developer tools\n\nconst buildScoringCriteria = (dimensions) => {\n  if (!dimensions || !Array.isArray(dimensions)) {\n    return '- No scoring criteria defined';\n  }\n\n  return dimensions.map(dim => {\n    // Convert snake_case to Title Case (seniority_match -> Seniority Match)\n    const name = dim.name\n      .replace(/_/g, ' ')\n      .replace(/\\b\\w/g, l => l.toUpperCase());\n\n    return `- ${name}: ${dim.description}`;\n  }).join('\\n');\n};\n\n// =====================================================================\n// BUILD DETAILED SCORES JSON STRUCTURE\n// =====================================================================\n// Builds the JSON structure for AI response with all dimension names\n// This can be used in the prompt if you want dynamic JSON structure too\n// Example output:\n// {\n//   \"seniority_match\": <number 1-10>,\n//   \"domain_match\": <number 1-10>,\n//   ...\n// }\n\nconst buildResponseStructure = (dimensions) => {\n  if (!dimensions || !Array.isArray(dimensions)) {\n    return '{}';\n  }\n\n  const scoreFields = dimensions.map(dim =>\n    `    \"${dim.name}\": <number 1-10>`\n  ).join(',\\n');\n\n  return `{\\n${scoreFields}\\n  }`;\n};\n\n// =====================================================================\n// GENERATE OUTPUT FIELDS\n// =====================================================================\n\nconst scoringCriteriaText = buildScoringCriteria(scoringConfig.dimensions);\nconst detailedScoresStructure = buildResponseStructure(scoringConfig.dimensions);\n\n// =====================================================================\n// OUTPUT\n// =====================================================================\n\nreturn [{\n  json: {\n    // Pass through all original job data\n    ...job,\n\n    // Add dynamic scoring criteria text (for use in Message a model prompt)\n    _scoring_criteria: scoringCriteriaText,\n\n    // Add dynamic JSON structure (optional - use if you want dynamic detailed_scores)\n    _detailed_scores_structure: detailedScoresStructure,\n\n    // Include full scoring config for reference/debugging\n    _scoring_config: scoringConfig\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        128
      ],
      "id": "2f373cc0-313a-4aad-92db-23338eeb643e",
      "name": "Add Scoring Criteria"
    }
  ],
  "pinData": {},
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "Loop Over Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Jobs": {
      "main": [
        [
          {
            "node": "Workflow Complete",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          },
          {
            "node": "Add Scoring Criteria",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Format Job Card",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Job Card": {
      "main": [
        [
          {
            "node": "Insert email row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert email row": {
      "main": [
        [
          {
            "node": "Loop Over Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Scoring Criteria": {
      "main": [
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "49be9a9e-f70c-414a-8bdb-7333100b813e",
  "id": "wdbaREmYAkpTiKry",
  "tags": []
}